#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0364>
問題文============================================================
 Ｂ君は人気のゲーム「ダンジョン」で遊んでいる。
 ゲームは、W×H 個のマス目状に区切られた長方形の盤面上で行われる。
 マスの位置を表すために、各マスには列番号と行番号が割り当てられている。
 列番号がx、行番号がy のマスは(x, y)で表される。
 左上隅がマス(0, 0)、右下隅がマス(W-1, H-1)である。
 
 Ｂ君はキャラクターのボムボム君を動かして、ゲームのクリアを目指す。
 ボムボム君は、最初スタート地点のマス（0, 0）にいる。
 盤面上にいる全ての敵を倒すとゲームクリアとなる。
 敵が動くことはないが、ボムボム君は、以下の２種類の行動を何度でもとることができる。
 
 上下左右の方向へ１マス動く。ただし、盤面の外に出てはいけない。
 爆弾を使用し、自分がいるマスと列番号が同じマスにいる敵と、行番号が同じマスにいる敵を一掃する。
 ボムボム君は1 マス動くためにコスト１を消費する。
 爆弾の使用回数に制限はなく、爆弾を使用するコストは発生しない。
 また、ボムボム君は爆弾の影響を受けることはなく、敵がいるマスにも移動することができる。
 
 盤面の大きさと敵の情報が与えられたとき、ボムボム君が全ての敵を倒すための最小のコストを出力するプログラムを作成せよ。
=================================================================

解説=============================================================
ボンバーマン方式、
 
 ある、列wまで進むことを決め打ちすると、コストは、wとwよりも右側にいる敵の中でもっとも大きいy
 後ろから順番に見て行くと、前の状態を保存できて楽
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    int W,H,N; cin >> W >> H >> N;
    vector<int> X(W);
    for(int i = 0; i < N;i++){
        int x,y; cin >> x>>y;
        X[x] = max(X[x],y);
    }
    int res = INF;
    int tmp = 0;
    for(int i = W-1; i>=0;i--){
        res = min(res,i + tmp);
        tmp = max(tmp,X[i]);
    }
    cout << res << endl;
	return 0;
}
