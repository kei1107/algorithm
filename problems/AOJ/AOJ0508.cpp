#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0508>
問題文============================================================
両端にリングのついた紐を考える.リングは正整数が付いていて,紐を区別する.
紐の両端のリングには異なる数 a, b が付けられる.これを,[a, b] と記述する.
複数の紐があり,一方の紐と他方の紐のリングに付いている数が同じ場合,そのリングのところで,
これらの紐をつなげることができて,つなげてできたものを鎖と呼ぶことにする.
例えば,[1, 3] と [3, 4] という紐からは [1, 3, 4] という鎖ができる.
紐と鎖や鎖同志も同じ整数が付いているリングのところでつなげることができるものとする.

例えば,鎖 [1, 3, 4] と紐 [5, 1] からは [5, 1, 3, 4] ができ,
鎖 [1, 3, 4] と鎖 [2, 3, 5] からは, 中央でクロスしたような形になる.
鎖 [1, 3, 4] と鎖 [4, 6, 1] からは, 輪の形ができる.

このように様々な形ができるが, そのうちの一部で,
同じ数の付いたリングは一度だけたどるつながった複数の紐を鎖と呼ぶことにする.
例えば,鎖 [1, 3, 4] と鎖[2, 3, 5] からできる,中央でクロスしたような形には,
[1, 3, 5],[2, 3, 4] という鎖も含まれ,
鎖 [1, 3, 4] と鎖 [4, 6, 1] からできる輪には, 
[1, 3, 4, 6],[3, 4, 6, 1],[4, 6, 1, 3]などの鎖が含まれる.

これらの鎖に対して,含まれる数の個数を長さと定義する. 
与えられた複数の紐に対して,つなげられるものはすべてつなげると1つ以上の鎖を含む形ができる.
そのうちの最大の鎖の長さを求めるプログラムを作成せよ.

入力データ の最初の行には紐の個数である正整数 1 ≤ n ≤ 100 が書いてあり,
つづく n 行のそれぞれには, 空白で区切られた
2 つの整数 a, b が書いてあり 1 ≤ a < b ≤ 100 となっている.
各行の 2 つの整数は 1 つの紐の両端の整数を表わす.
=================================================================
入力=============================================================
入力は複数のデータセットからなる．n が 0 のとき入力が終了する．データセットの数は 10 を超えない．
================================================================
出力=============================================================
データセットごとに、最大の鎖の長さを１行に出力する．
================================================================

解説=============================================================
閉路がありうるため、木の直径といった考えができない。
ただ、グラフでの各頂点から最長距離の最大が求める答えであり、各頂点は最大100
貪欲に経路をたどっていった場合,各頂点に対してdfsで経路を辿っていくことになり, 
テストケースは最大10個であるが, 制約が8sであるため十分間に合う
================================================================
*/

ll ans;
void dfs(ll n, ll dep, vector<vector<ll>>& G, vector<int>& used) {
	bool f = false;
	for (auto next : G[n]) {
		if (used[next] == 0) {
			f = true;
			used[next] = 1;
			dfs(next, dep + 1, G, used);
			used[next] = 0;
		}
	}
	if (!f) {
		ans = max(ans, dep);
	}
}

int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
	ll n;
	while (cin >> n, n) {
		ans = 0;
		vector<vector<ll>> G(101);
		for (int i = 0; i < n;i++) {
			ll x, y; cin >> x >> y; x--;y--;
			G[x].push_back(y); G[y].push_back(x);
		}

		vector<int> used(101, 0);
		for (int i = 0; i < 101;i++) {
			used[i] = 1;
			dfs(i, 1, G, used);
			used[i] = 0;
		}
		cout << ans << endl;
	}
	return 0;
}