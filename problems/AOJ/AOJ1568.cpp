#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1568>
問題文============================================================
 ジェニファーとマリアンはカーラに文字列Sをプレゼントしました。
 しかし、カーラは文字列Sをもらっても嬉しくありません。
 文字列Tが欲しかったのです。
 3人は協力して文字列Sを文字列Tに変えることにしました。
 最初にジェニファーが文字を任意の順番に並び替えます。
 
 次にマリアンが２種類のアルファベットの小文字を交換することを任意の回数行います。
 この操作では、例えば以下のように、文字列中の同じ文字が全て交換されます。
 aab → aとbを交換 → bba
 aab → aとcを交換 → ccb
 最後にカーラがある1文字を別の1文字に置換することをTになるまで繰り返します。
 ジェニファーとマリアンはカーラの置換回数が少なくなるようにしてあげることにしました。
 カーラが行う置換の回数の最小値を求めてください。
 
=================================================================

解説=============================================================
考察を進めると、SとTの各文字の個数だけに注目すればいいことがわかる
 ソートされたSとTの各文字の個数に関して順番にその差の絶対値の和をとり、その半分が答え
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    string S,T; cin >> S >> T;
    int sc[26] = {0};
    int tc[26] = {0};
    for(char c : S) sc[c - 'a']++;
    for(char c : T) tc[c - 'a']++;
    sort(sc,sc+26); sort(tc,tc+26);
    int ans = 0;
    for(int i = 0; i < 26;i++) ans += abs(sc[i] - tc[i]);
    cout << ans / 2 << endl;
	return 0;
}
