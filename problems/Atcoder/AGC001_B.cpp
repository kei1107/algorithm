#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://agc001.contest.atcoder.jp/tasks/agc001_b>
問題文============================================================
 高橋君は 1 辺の長さが N の 3 枚の鏡を正三角形状に組み合わせました。 三角形の頂点をそれぞれ a,b,c とします。
 
 高橋君は、辺 ab 上の頂点 a から X の点から、辺 bc と平行に不思議な光を発射しました。
 不思議な光は、普通の光と同じように真っすぐ進み、鏡に当たると反射するのですが、
 不思議な光がすでに通った点に当たったときにも反射をします。
 
 不思議な光を発射した時、不思議な光は必ず発射した点に戻ってくることが証明できます。
 このとき、光の軌跡の長さが全体でいくらになるかを求めて下さい。

=================================================================

解説=============================================================

 制約から値が大きいので、貪欲に行うと部分点は得ることができるかもしれないが、
 満点は難しい
 
 よって頑張って規則性を見出す
 
 問題の図をよく見ると、軌跡の道中で光の開始点が等しい、いくつかの平行四辺形ができているのがわかる
 
 例えば 光が一回反射して、次の壁に当たった時（移動距離がNの時)
 光の開始点が右下で 上(下）辺が X , 斜辺が N - X の平行四辺形ができる
 
 そして、その次、光が最初から4回反射した時
 光の開始点が右下で 上(下）辺が X , 斜辺が N - X - (N - (N - X)) の平行四辺形ができる
 
 
 ここでこういった平行四辺形について考察を進めると
 上(下)辺が a , 斜辺が b とした時
 
 if a <= b then
     次の平行四辺形に映るまでの光の移動距離 = (b/a) * 2 * a
     次の平行四辺形の形 : a = a , b = b - b/a * a
 else
     a <= b の場合の条件式を a,bに関した逆転させた式
 
 ということがわかる
 
 最後に、最初の光の発射点に戻るということは a or b が 0になることであり
 各々の条件式において b%a == 0 となることであるため、これで終端の判定ができる
 また、その時の移動距離は 平行四辺形の光の開始点が右下なため、 1本分光の距離が長いので
 その分を考慮してやれば答えになる
================================================================
*/
ll solve(){
    ll ret = 0;
    ll N,X; cin >> N >> X;
    
    ret += N;
    ll a = X;
    ll b = N - X;
    while(true){
        if(a <= b){
            ret += b/a * 2 * a;
            if(b%a == 0){
                ret -= a;
                break;
            }
            b = b - b/a*a;
        }else{
            ret += a/b * 2 * b;
            if(a%b == 0){
                ret -= b;
                break;
            }
            a = a - a/b*b;
        }
    }
    return ret;
}
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    cout << solve() << endl;
	return 0;
}
