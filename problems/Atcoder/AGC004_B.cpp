#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://agc004.contest.atcoder.jp/tasks/agc004_b>
問題文============================================================
 高橋君は異世界に住んでいます。 この世界には N 色のスライムがいます。
 最初、高橋君はどの色のスライムも飼っていません。 高橋君の目標は、全色のスライムを一緒に飼うことです。
 
 高橋君は次の 2 種類の操作を行えます。
 
 今飼っていないスライムの色 i (1≤i≤N) をひとつ選ぶ。 色 i のスライムを捕まえて飼う。この操作には ai 秒掛かる。
 
 魔法を唱える。 すると、今飼っている各スライムについて、色 i (1≤i≤N−1) のスライムは色 i+1 へ変色する。
 ただし、色 N のスライムは色 1 へ変色する。 この操作には x 秒掛かる。
 
 高橋君が全色のスライムを一緒に飼うためには、最短で合計何秒掛かるかを求めてください。
=================================================================

解説=============================================================

 全体でどこのスライムを捕獲して何回変色させるのが最適かどうかといった事ではなく
 k(0 <= k <= N-1)回変色させる事を前提とした時、あるスライムiはどこで捕まえるのが最適かといった事を考える
 
 全体で k 回変色させることをあらかじめ決めうちしておくと
 
 あるスライム i は
 
 スライムi-kを捕まえて k回変色
 1回変色させたのち、 スライムi-k+1を捕まえて k-1回変色
 .
 .
 .
 j回変色させたのち、 スライムi-k+jを捕まえて k-j回変色
 
 といった考えができるので、i-k ... i までのどのスライムを捕まえても良くなる
 
 よって,
 
 k回変色させると決めた時
 あるスライムiについて捕まえるスライム min{ ai,ai-1,ai-2,...ai-k}
 を b とすると
 k*x + Σb
 が全スライムを揃えるのに最小なコストとなる
 
 ここで、 k を k + 1 にするとき b のテーブルを使い回せば 各スライムについて b はO(1)でもとまるので
 O(N^2)の計算量となり間に合う
 
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    ll N,x; cin >> N >> x;
    vector<ll> a(N);
    for(auto &in:a) cin >> in;
    vector<ll> b(N,LINF);
    ll ans = LINF;
    // i * x + Σb[j]_i
    for(int i = 0; i < N;i++){
        ll tmp = 0;
        for(int j = 0; j < N;j++){
            b[j] = min(b[j],a[(j-i+N)%N]);
            tmp += b[j];
        }
        ans = min(ans,i*x+tmp);
    }
    cout << ans << endl;
	return 0;
}
