#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://agc014.contest.atcoder.jp/tasks/agc014_b>
問題文============================================================
 高橋君は木の問題が苦手です。そこで、青木君は高橋君の練習相手になってあげることにしました。
 
 まず、高橋君は N 頂点からなる木を用意し、頂点に 1 から N の番号を付けました。 そして、各辺に 0 と書きました。
 
 次に、青木君は高橋君に M 個のクエリを与えました。i 個目のクエリは以下のような内容です。
 
 頂点 ai と頂点 bi を結ぶパス上の辺すべてに対して、書かれている数を 1 増やす。
 全てのクエリを終えた後、高橋君は青木君にどの辺を見ても書かれている数が偶数になったと伝えました。
 しかし、青木君は最初に高橋君が用意していた木を確認していなかったので、
 高橋君が正しくクエリを処理できたか分かりませんでした。
 
 青木君を助けるために、高橋くんの言う性質を満たす木が存在するかどうかを判定してください。
=================================================================

解説=============================================================
適当に投げて見たら通った。
 全ての頂点の次数が偶数であればok
 一つでも奇数が存在すると　木が作れないことが証明できるらしい（根つき木やLCAで考える）
 詳細は解説を読む
 と思ったけど、考えて見たら確かにア
 
 辺(a,b)が存在し、木の根が r とすれば
 a-r-b への経路と a-b への経路　を同一視しても問題ない
 
 なぜなら問題は利用回数が偶数であればいいので, a-bが根を経由しなくても a-r と r-b をたどる際に
 必ず a or b から r への辺が偶数回使用されるためである
 
 よって、この考えから全ての辺が r を経由すると考えた時、全ての頂点の字数が偶数回存在しないと
 各辺の利用回数が偶数回にならないことは　実際に木を自分で書いて見たりすると明らか
================================================================
*/
string solve(){
    ll N,M; cin >> N >> M;
    vector<ll> a(M),b(M);
    for(int i = 0; i < M;i++){
        cin >> a[i] >> b[i];
    }
    vector<ll> cnt(N+1);
    for(int i = 0; i < M;i++){
        cnt[a[i]]++; cnt[b[i]]++;
    }
    for(auto v:cnt){
        if(v&1) return "NO";
    }
    return "YES";
}
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    cout << solve() << endl;
	return 0;
}
