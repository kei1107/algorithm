#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
 <url:https://arc063.contest.atcoder.jp/tasks/arc063_a>
問題文============================================================
 きつねの次郎と三郎が一次元リバーシで遊んでいます。
 一次元リバーシでは、盤面には白か黒の石が一列に並んだ状態となっており、列の右端か左端に新たに石を打っていきます。
 通常のリバーシと同じように、たとえば白の石を打つことで黒の石を挟むと、挟まれた黒の石は白い石に変わります。
 
 ゲームの途中で三郎に急用ができて帰ってしまうことになりました。このとき、盤面の状態は文字列 S で表されます。
 石は |S| (文字列の長さ) 個並んでおり、
 左から i (1≦i≦|S|) 個目の石の色は、S の i 文字目が B のとき黒、W のとき白です。
 
 次郎は現在の盤面に対して、できるだけ少ない個数の石を新たに打つことで全ての石を同じ色にしようと考えました。
 最小で何個の石を打てばよいかを求めてください。
=================================================================

解説=============================================================

 左と右から順番にひっくり返して行った場合をシミュレーションすれば良い
 
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    string S; cin >> S;
    int ans = INF;
    int tmp = 0;
    for(int i = 0; i < (int)S.length()-1;i++){
        if(S[i] != S[i]+1) tmp++;
    }
    ans = min(ans,tmp);
    tmp = 0;
    for(int i = (int)S.length()-1; i>0;i--){
        if(S[i] != S[i-1]) tmp++;
    }
    ans = min(ans,tmp);
    cout << ans << endl;
	return 0;
}
