#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://arc068.contest.atcoder.jp/tasks/arc068_b>
問題文============================================================
 すぬけくんはカードゲームで遊ぶことにしました。
 N 枚からなるカードの山があり、上から i 枚目のカードには整数 Ai が書かれています。
 
 すぬけくんはこのカードの山に対し 0 回以上、以下の操作を行い、
 残ったカードに書かれた値が互いに異なるようにしたいです。
 最大で何枚のカードを残すことが可能か求めなさい。
 なお、N は奇数であり、少なくとも 1 枚のカードを残すことが可能であることが保証されます。
 
 操作：カードの山から任意の 3 枚のカードを抜き出す。
 抜き出したカードのうち書かれた値が最大であるようなカード 1 枚と
 最小であるようなカード 1 枚の合計 2 枚を選んで食べる。その後残った 1 枚をカードの山に戻す。
=================================================================

解説=============================================================

 a,b,cをそれぞれ異なる数値(a<b<c)だとすると
 今回の問題で考えられるパターンは
 a,b,c => b
 a,a,b => a
 a,a,a => a
 
 といったパターンである。
 ここで数値が重複しているパターンについて考えると
 aに関していえば、 aが２個あるならば上のようにして、2個をそのまま用いることによって１個にできる
 また、３個以上ある場合は、すべて同じ値にすることによって最終的に２個または１個にできる。
 よって、結果的に２個同じ数字がある場合について考察を進めればよく、
 
 ２個同じ数字があるのであれば、１個別の数字を使って１個にすれば良いということになる。
 ここで、行動を最適にするために、用いるもう１個の数字をできるだけ同じく２個重複している数字を
 使っていけば良い
 
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    ll N; cin >> N;
    vector<ll> A(N);
    for(auto& in:A) cin >> in;
    const int MAX_N = 1e5+1;
    vector<ll> C(MAX_N,0);
    for(auto &v:A) C[v]++;
    sort(C.begin(),C.end(),greater<ll>());
    for(int i = 0; i < (int)C.size();i++){
        if(C[i] >= 3){
            if(C[i]%2 == 1) C[i] = 1;
            else C[i] = 2;
        }
    }
    sort(C.begin(),C.end(),greater<ll>());
    for(int i = 0; i < (int)C.size();i++)if(C[i] == 2){ C[i] = 1; C[i+1]--; }
    cout << accumulate(C.begin(),C.end(),0LL) << endl;
	return 0;
}
