#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://arc075.contest.atcoder.jp/tasks/arc075_b>
問題文============================================================
 あなたが散歩していると、突然 N 体の魔物が出現しました。
 それぞれの魔物は 体力 という値を持ち、i 体目の魔物の出現時の体力は hi です。
 体力が 0 以下となった魔物は直ちに消滅します。
 
 幸い、あなたは熟練の魔法使いであり、爆発を引き起こして魔物を攻撃できます。
 一回の爆発では、以下のように魔物の体力を減らすことができます。
 
 生存している魔物を一体選び、その魔物を中心に爆発を引き起こす。
 爆発の中心となる魔物の体力は A 減り、その他の魔物の体力はそれぞれ B 減る。
 ここで、A と B はあらかじめ定まった値であり、A>B である。
 すべての魔物を消し去るためには、最小で何回の爆発を引き起こす必要があるでしょうか？
=================================================================

解説=============================================================

 蟻本の練習問題に類題があるね。（すぐ気づけなくて、悩んでしまった。精進が足りない）
 
 にぶたん
 
 先に m 回攻撃すると決めてしまえば、
 全ての敵に m*B のダメージが入っている状態とみなすことができる。
 そして、まだ体力が残っている敵に対して A - B のダメージを与えていく問題と考えることができる
 
 したがって、敵一体に対して h > m*B であれば
 倒すのに　(h - m*B + A - B - 1 )/(A-B) 回　必要だとわかる
 
 よって全ての敵に対して 必要な回数が m 以下であるか、 m より大きいかで判定できる
 
================================================================
*/
ll N,A,B;
vector<ll> h;

bool C(ll m){
    ll cnt = 0;
    ll dif = A - B;
    for(int i = 0; i < N;i++){
        ll X = h[i] - m*B;
        if(X <= 0) continue;
        cnt += (X + dif - 1)/dif;
    }
    return cnt <= m;
}
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    cin >> N >> A >> B;
    h.resize(N);
    for(auto &in:h) cin >> in;
    ll l = 0, r = INF;
    while(r - l > 1){
        ll m = (l + r)/2;
        if(C(m)){
            r = m;
        }else{
            l = m;
        }
    }
    cout << r << endl;
	return 0;
}
