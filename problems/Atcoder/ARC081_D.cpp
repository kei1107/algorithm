#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://arc081.contest.atcoder.jp/tasks/arc081_b>
問題文============================================================
 2×N のマス目があります． すぬけ君は，このマス目に N 個のドミノを，重ならないように敷き詰めました．
 ここで，ドミノは，1×2 または 2×1 のマス目を覆うことができます．
 
 すぬけ君は，赤色，水色，緑色の 3 色を使って，これらのドミノを塗ることにしました．
 このとき，辺で接しているドミノは異なる色で塗るようにします．
 ここで，必ずしも 3 色すべてを使う必要はありません．
 
 このような塗り方が何通りあるかを mod 1000000007 で求めてください．
 
 ただし，ドミノの敷き詰め方は，文字列 S1,S2 を用いて，次のようにして与えられます．
 
 各ドミノは，それぞれ異なる英小文字または英大文字で表される．
 Si の j 文字目は，マス目の上から i 番目，左から j 番目のマスにどのドミノがあるかを表す．
 
 制約
 1≤N≤52
 |S1|=|S2|=N
 S1,S2 は英小文字または英大文字からなる
 S1,S2 は正しいドミノの敷き詰め方を表している

=================================================================

解説=============================================================
直前のドミノがどのようになっているかで、今見ているドミノの塗り方が限られるので、
 パターンを全部確認して、かけていけば良い
================================================================
*/

const ll MOD = 1e9 + 7;
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    ll N; cin >> N;
    string S1,S2; cin >> S1 >> S2;
    ll ans = 1;
    ll i = 0;
    if(S1[i] == S2[i]){
        /*
         X
         X
         */
        ans *= 3;
        i++;
    }else{
        /*
         X X
         Y Y
         */
        ans *= 6;
        i+=2;
    }
    for(;i<N;){
        if(S1[i] == S2[i]){
            if(S1[i-1] == S2[i-1]){
                /*
                 X Y
                 X Y
                 */
                ans *= 2;
            }else{
                /*
                 YY X
                 ZZ X
                 */
                ans *= 1;
            }
            i++;
        }else{
            if(S1[i-1] == S2[i-1]){
                /*
                 Y XX
                 Y YY
                 */
                ans *= 2;
            }else{
                /*
                 AA XX
                 BB YY
                 */
                ans *= 3;
            }
            i += 2;
        }
        ans%=MOD;
    }
    cout << ans << endl;
	return 0;
}
