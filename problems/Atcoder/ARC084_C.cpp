#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60
/*
<url:>
問題文============================================================
今年もすぬけ祭の季節がやってきました。
りんごさんは、まず手始めにすぬけ君召喚の儀式を執り行おうと思っています。
儀式には祭壇が必要で、祭壇は上部、中部、下部の3 つのカテゴリーのパーツ1 つずつからなります。
祭壇の3 カテゴリーのパーツがそれぞれN 個ずつあります。
i 個目の上部のパーツのサイズはAi 、i 個目の中部のパーツのサイズはBi 、
i 個目の下部のパーツのサイズはCi です。
祭壇を作るにあたっては、中部のパーツのサイズは上部のパーツのサイズより真に大きく、
下部のパーツのサイズは中部のパーツのサイズより 真に大きくなければなりません。
逆に、この条件を満たす任意の3 つのピースを組み合わせて祭壇を作ることができます。
りんごさんが作ることのできる祭壇は何種類あるでしょうか。
ただし、2 つの祭壇が異なるとは、上部、中部、下部に使われるピースのうち
少なくとも1 つが異なることを言います。
=================================================================
解説=============================================================
二部探索＋累積和

よくよく考えると,中部のあるパーツBは上部のBより小さいパーツの合計(=>累積和+二部探でO(n logn))
であり、下部のあるパーツCは中部のCより小さいパーツの合計(=>上で用いた合計を考慮し、同様にできる)
となるので、二部探索＋累積和でO(n log n)でうれしい
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
	ll N; cin >> N;
	vector<ll> A(N), B(N), C(N);
	for (int i = 0; i < N;i++) cin >> A[i];
	for (int i = 0; i < N;i++) cin >> B[i];
	for (int i = 0; i < N;i++) cin >> C[i];
	sort(A.begin(), A.end());
	sort(B.begin(), B.end());
	sort(C.begin(), C.end());

	vector<ll>BA(N+1, 0);
	for (int i = 0; i < N;i++) {
		BA[i+1] = lower_bound(A.begin(), A.end(), B[i]) - A.begin();
	}
	for (int i = 0; i < N;i++) {
		BA[i + 1] += BA[i];
	}
	ll res = 0;
	for (int i = 0; i < N;i++) {
		res += BA[lower_bound(B.begin(), B.end(), C[i]) - B.begin()];
	}
	cout << res << endl;
	return 0;
}