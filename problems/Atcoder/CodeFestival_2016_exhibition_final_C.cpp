#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://cf16-exhibition-final-open.contest.atcoder.jp/tasks/cf16_exhibition_final_c>
問題文============================================================
 チーターと不正者がニムをすることになりました。 このゲームでは、N 個の石の山を使います。
 最初に i 番目の山には ai 個の石があります。 チーターが先手で、交互にターンを取ります。
 それぞれのターンでは、プレイヤーは一つの山を選び、その山から一個以上の石を取り除きます。
 ターンが回ってきたときに操作ができなくなったプレイヤーの負けです。
 
 しかし、ゲームが始まる前に、
 不正者はチーターがどのような動きをしても必ず勝つことができるように少し不正をすることにしました。
 それぞれの山から、不正者は 0 個または 1 個の石を取り除き、ゲームが始まる前に食べます。
 不正者が必ず勝てるようにする方法が複数通りある場合は、食べる石の個数を最小にするようにしたいです。
 
 不正者が食べる石の個数を求めてください。 不正をしても不正者が必ず勝つようにできない場合は、-1 を出力してください。
=================================================================

解説=============================================================

 ゲーム理論より 全ての山の xor を 0 にしたい
 ここで、初期状態のxor を x とし　ある値 a[i] を a[i]-1 にすると
 
 x = x^(a[i]^(a[i]-1))
 
 となる
 さて、　a[i]^(a[i]-1) は　必ず　2^k-1 の形になることに注目する
 
  サンプル1では
   2^3^4 = (101)_2
     3^2 = (1)_2
     2^1 = (11)_2
     4^3 = (111)_2
 
 である
 
 この(101)_2を 0 にするには　、　まず
 
 3桁目の最上位１に注目して
 4=>3にして
 (101)^(111) = (10)
 次に2桁目の最上位１に注目して
 (10)^(11) = (1)
 同様に
 (1)^(1) = (0) = 0
 
 このように最上位から順番に見て行くことによって確実かつ最適に値を0に近づけることができる
 
 よって、先に a[i] によって作れる 2^k-1 の値を確認しておき
 x に関して最上位から順番に見て行き 変化させていけば良い
 
================================================================
*/

ll solve(){
    ll N; cin >> N;
    vector<ll> a(N);
    for(auto &in:a) cin >> in;
    ll x = 0;
    for(int i = 0; i < N;i++) x ^= a[i];

    // a[i] -> a[i] - 1 := x^(a[i]^(a[i]-1)) = x^(2^k - 1)
    bool f[31] = {false};
    for(int i = 0; i < N;i++){
        ll t = a[i]^(a[i]-1);
        ll cnt = 0, n = 1;
        while(n <= t){cnt++; n<<=1;}
        f[cnt] = true;
    }
    ll ret = 0;
    for(int i = 30; i >= 0; i--){
        if((x>>i)&1){
            if(f[i+1] == false) return ret = -1;
            x^=((1<<(i+1)) - 1); ret++;
        }
    }
    return ret;
}
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    cout << solve() << endl;
	return 0;
}
