#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
<url:https://code-festival-2016-quala.contest.atcoder.jp/tasks/codefestival_2016_qualA_c>
問題文============================================================
 高橋君は、英小文字のみからなる文字列 s を持っています。
 高橋君は s に対して、次の操作をちょうど K 回行います。
 
 s から好きな位置の文字をひとつ選び、その文字を次のアルファベットへ変える。
 ただし、z の次のアルファベットは a であるとする。
 
 例えば、aaz の 2 文字目を選んで操作を行うと、aaz → abz となります。
 続けて、abz の 3 文字目を選んで操作を行うと、abz → aba となります。
 
 高橋君は、操作をちょうど K 回行った後の s を、辞書順でできるだけ小さくしたいと考えています。
 操作をちょうど K 回行った後の s のうち、辞書順で最小のものを求めてください。
 
 制約
 1≤|s|≤10^5 である。 ただし、|s| は s の長さを表す。
 s は英小文字のみからなる。
 1≤K≤10^9
=================================================================

解説=============================================================

 文字の長さが固定の場合、
 文字列最小となるには、第一文字目から順に文字が a 以外の時に、aにすることである
 
 よって、一文字目から順に見ていった時、 a にできるのであれば　a にしていき
 できなければ　そのままにする（aにできなけければ　次のアルファベットは必ず辞書順的に大きくなる）
 
 最後に交換回数が余る場合,文字の一番最後の文字をその回数だけ変化させれば最適
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
    string s; cin >> s;
    ll K; cin >> K;
    for(auto& c:s){
        if(c == 'a') continue;
        ll t = (26 - (c - 'a'))%26;
        if(K >= t){
            c = 'a';
            K-=t;
        }
    }
    
    s[s.length()-1] = (s[s.length()-1] - 'a' + K)%26 + 'a';
    
    cout << s << endl;
	return 0;
}
