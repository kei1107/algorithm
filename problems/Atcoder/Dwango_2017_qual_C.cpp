#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int INF = 1e9;
const ll LINF = 1e18;

/*
 <url:https://dwacon2017-prelims.contest.atcoder.jp/tasks/dwango2017qual_c>
 問題文============================================================
 スキーが大好きなタカシくんは、ニコニコスキー場でリフト係のアルバイトを始めました。
 このスキー場には搬器（いす）1 台あたりの定員が 4 人であるリフトが 1 基あり、
 ここにスキー客が 1 人から 4 人までのグループで並びに来ます。
 
 ある日、リフトの待ち行列が長くなったことに困ったタカシくんは、スキー客にリフトの相乗りをしてもらおうと考えました。
 タカシくんは、搬器が 1 台乗り場に着くごとに以下のような手順でスキー客のグループをその搬器に案内することにしました。
 
 最初に、待ち行列の先頭にいるグループを搬器に案内する。
 現在の搬器に相乗りしても定員を超えないようなグループが存在する限り、そのようなグループを搬器に案内する。
 ただし、そのようなグループが複数存在する場合は、待ち行列での位置に関わらず、いずれのグループを案内しても構わない。
 今、リフトには N グループのスキー客が並んでおり、
 待ち列の先頭から i(1≦i≦N) 番目のグループは Ai 人のスキー客からなります。
 タカシくんがうまくスキー客のグループを案内することによって、
 最短で何台目の搬器で今並んでいるグループをすべて運びきることができるかを求めて下さい。
 
 =================================================================
 
 解説=============================================================
 
 最適な組み合わせを先に作ってしまえば順番なんて関係ない
 以下、そのパターンを示す 左から順番に優先順位が高い
 
 {4}, {3,1} , {2,2}/{3}, {2,1,1}/{2,1} , {1,1,1,1}/{1,1,1}/{1,1}/{1}
 
 あとは、このパターンを満たす組み合わせの個数を計算すれば良い
 ================================================================
 */
void solve(){
    ll N; cin >> N;
    vector<ll> A(N);
    ll cnt[5] = {0};
    for(auto &in:A){ cin >> in; cnt[in]++; }
    ll ans = 0;
    
    ans += cnt[4]; cnt[4] = 0;
    ll to = min(cnt[3],cnt[1]);
    ans += to;
    cnt[3] -= to; cnt[1] -= to;
   
    ans += cnt[3];
    
    ans += cnt[2]/2;
    cnt[2] -= cnt[2]/2 * 2;

    if(cnt[2]){
        ans++; cnt[1]-=2;
    }
    if(cnt[1] >= 0) ans += (cnt[1]+3)/4;
    cout << ans << endl;
}
int main(void) {
    cin.tie(0); ios::sync_with_stdio(false);
    solve();
    return 0;
}

