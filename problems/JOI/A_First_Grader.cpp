#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
 <url:https://www.ioi-jp.org/joi/2010/2011-yo-prob_and_sol/2011-yo-t4/2011-yo-t4.html>
 問題文============================================================
 JOI君は小学 1 年生である．
 JOI君は教わったばかりの足し算，引き算がとても好きで，
 数字が並んでいるのを見ると最後の 2 つの数字の間に「=」を入れ，
 残りの数字の間に必ず「+」または「-」を入れて等式を作って遊んでいる．
 例えば「8 3 2 4 8 7 2 4 0 8 8」から，等式「8+3-2-4+8-7-2-4-0+8=8」を作ることができる．
 
 JOI君は等式を作った後，それが正しい等式になっているかを計算して確かめる．
 ただし，JOI君はまだ負の数は知らないし，20 を超える数の計算はできない．
 したがって，正しい等式のうち左辺を左から計算したとき計算の途中で現れる数が全て
 0 以上 20 以下の等式だけがJOI君が確かめられる正しい等式である．
 例えば，
 「8+3-2-4-8-7+2+4+0+8=8」は 正しい等式だが，途中に現れる 8+3-2-4-8 が
 負の数なのでJOI君はこの等式が正しいかどうか確かめることができない．
 
 入力として数字の列が与えられたとき，JOI君が作り，
 確かめることができる正しい等式の個数を求めるプログラムを作成せよ
 =================================================================
 解説=============================================================
 普通のdp / dp[i][j] := i番目の数字を見た時,値jである総数
 しかし、初期化の時にdp[0][0] = 1としてしまうと、
 数字の最初（もしくは最初から連続した）値が０の時に、余分に加算されてしまうため、
 その部分のみ例外処理が必要
 ================================================================
 */
int main(void) {
    cin.tie(0); ios::sync_with_stdio(false);
    ll N; cin >> N;
    vector<ll> v(N);
    for(auto &x:v) cin >> x;
    vector<vector<ll>> dp(N,vector<ll>(21,0));
    
    int s = -1;
    for(int i = 0;i < N-1;i++){
        if(v[i] == 0)continue;
        dp[i][0] = 1;
        s = i;
        break;
    }
    if(s == -1) s = N - 2;
    for(int i = s; i < N - 1;i++){
        for(int j = 0; j <= 20;j++){
            if(dp[i][j] == 0)continue;
            if(j + v[i] <= 20){
                dp[i+1][j + v[i]] += dp[i][j];
            }
            if(j - v[i] >=0 ){
                dp[i+1][j - v[i]] += dp[i][j];
            }
        }
    }
    cout << dp[N-1][v[N-1]] << endl;
    return 0;
}
