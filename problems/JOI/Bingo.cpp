#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
<url:https://www.ioi-jp.org/joi/2008/2009-yo-prob_and_sol/2009-yo-t6/2009-yo-t6.html>
問題文============================================================
あるプログラミングコンテストでは， 競技後の懇親会でビンゴゲームをする習わしがある．
しかし， このビンゴゲームで使うビンゴカードは少々特殊で， 以下の条件に従って作成される．
	ビンゴカードは N 行 N 列のマス目に区切られており， 各マス目には正整数が１つずつ書かれている．それらの整数は全て異なる．
	マス目に書かれている整数は 1 以上 M 以下である．
	ビンゴカードに書かれているN×N個の整数の合計は S である．
	どの列を見たときも， 上から下に向かって整数は昇順に並んでいる．
	どのマス目の整数も， そのマス目より左の列のどの整数よりも大きい．

懇親会のために上の条件を満たすビンゴカードをできるだけたくさん作りたい． 
ただし， 同一のカードを2枚以上作ってはならない．
作ることができるビンゴカードの枚数の最大値を 100000 で割った余りを出力するプログラムを作成せよ．
=================================================================
解説=============================================================
ビンゴをN*Nの単調増加数列と考える
1~Mの範囲において
dp[j][k] := j番目のマスの時点で総和がkになっている時
のdpをおこなう
O(MSN^2)となり、通常間に合うか怪しいが、テストケースが弱いのか間に合う
================================================================
*/
const int MOD = 100000;
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
	int N, M, S; cin >> N >> M >> S;
	vector<vector<int>> dp(N*N + 1, vector<int>(S + 1));
	dp[0][0] = 1;
	for (int i = 0;i < M;i++) {
		for (int j = N*N - 1; j >= 0;j--){
			for (int k = 0; k < S - i;k++) {
				(dp[j + 1][k + i + 1] += dp[j][k]) %= MOD;
			}
		}
	}
	cout << dp[N*N][S] << endl;
	return 0;
}