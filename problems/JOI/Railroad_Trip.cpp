#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
<url:https://www.ioi-jp.org/joi/2014/2015-ho/2015-ho.pdf>
問題文============================================================
JOI 国には N 個の都市があり，それぞれ 1, 2, . . . , N の番号が付けられている．
また，鉄道が N − 1 本あり，それぞれ 1, 2, . . . , N − 1 の番号が付けられている．
鉄道 i (1 ≦ i ≦ N − 1) は，都市 i と都市 i + 1 を双方向に結んでいる．

JOI 国の鉄道に乗車する方法として，紙の切符で乗車する方法と，IC カードで乗車する方法がある．

• 鉄道 i に紙の切符で乗車する場合の運賃は Ai 円である．
• 鉄道 i に IC カードで乗車する場合の運賃は Bi 円である．ただし，IC カードで鉄道 i に乗車するに
  は，鉄道 i で使える IC カードを事前に購入しておく必要がある．
  鉄道 i で使える IC カードを購入するには Ci 円かかる．
  一度購入した IC カードは，何度でも使用することができる．

IC カードの方が金額の処理が簡単になるため，IC カードで乗車する場合の運賃の方が紙の切符で乗車する場合の運賃よりも安い．
すなわち， i = 1, 2, . . . , N − 1 に対して， Ai > Bi が成り立つ．
IC カードの仕様は鉄道ごとにすべて異なるため，どの i に対しても，鉄道 i で使える IC カードを他の鉄道で使用することはできない．
あなたは，JOI 国じゅうを旅行することにした．都市 P1 から出発し，P2, P3, . . . , PM の順に都市を訪れる予定である．
旅行は M − 1 日間の行程からなる．j 日目 (1 ≦ j ≦ M − 1) に都市 Pj から都市 Pj+1 に鉄道で移動する．
この際，いくつかの鉄道を乗り継いで移動することもある．
また，同じ都市を二度以上訪れることがあるかもしれない．
JOI 国の鉄道は速いので，どの都市からどの都市へも 1 日で移動することができる．
あなたは現在，どの鉄道の IC カードも持っていない．あなたは，あらかじめ，いくつかの鉄道の IC カードを購入し，
この旅行にかかる金額，すなわち，IC カード購入費用と乗車した鉄道の運賃の和をできるだけ少なくしたい．
=================================================================
解説=============================================================

線路は1..Nまで順番につながっているため、どのルートを通るのかについては明らか

ここでカードを買うべき場合について考える。
あるルートiをn回利用しなければならない時, Ai * n >= Bi * n + Ci　であれば
カードを買ったほうがいいのは明らかである。
よって、各ルートを何回通るかが分かれば、答えが分かる。
制約より、貪欲法はできないので、いもす法にて区間を何回利用するのかを求めれば
O(N)で解ける

================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
	ll N, M; cin >> N >> M;
	vector<ll> P(M);
	for (auto&p : P)cin >> p;
	vector<vector<ll>> ticket(N-1, vector<ll>(3));
	for (int i = 0; i < N - 1;i++) for (int j = 0; j < 3;j++) cin >> ticket[i][j];

	vector<ll> imos(N + 1, 0);
	for (int i = 0; i < M - 1;i++) {
		ll s = min(P[i], P[i + 1]),t = max(P[i], P[i + 1]);
		s--; t--;
		imos[s]++; imos[t]--;
	}
	for (int i = 1; i <= N;i++) {
		imos[i] += imos[i - 1];
	}

	ll res = 0;
	for (int i = 0; i < N-1;i++) {
		res += min(ticket[i][0] * imos[i], ticket[i][1] * imos[i] + ticket[i][2]);
	}
	cout << res << endl;
	return 0;
}