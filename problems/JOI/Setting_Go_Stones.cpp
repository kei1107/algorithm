#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
<url:https://www.ioi-jp.org/joi/2007/2008-ho-prob_and_sol/2008-ho.pdf>
問題文============================================================
白と黒の碁石をテーブルの上にならべて遊ぶ．まずテーブルの左端に碁石を置く．
次に左から 2 番目の場所に碁石を置く．これを n 回繰り返して n 個の碁石を横一列
にならべる．
ただし，新しく i 番目の碁石を置く際には，次のルールに従ってテー
ブル上の碁石を置き換える．
• i が奇数の場合: テーブルに置いてあった碁石は置き換えず，新しい碁石を左から i 番目に置く．
• i が偶数の場合: 新しく左から i 番目に置く碁石の色とテーブル上の右端の碁石の色が同じ場合は，
  テーブル上の碁石は置き換えず，新しい碁石を左から i 番目に置く．
  そうでない場合，すなわち，新しく左から i 番目に置く碁石の色とテーブル上の右端の碁石の色が異なる場合は，
  まずテーブル上の右端の連続した同色の碁石を全て取り除き，i 番目の碁石と同色の碁石に置き換える．
  そしてテーブルの右端に i 番目の碁石を置く．

例えば，最初の 7 個の碁石を置いた時点で，
○○●●○○○
となっていたとする．（○は白の碁石を，●は黒の碁石を表す．）
• 8 番目の碁石が白（○）の場合は，右端の碁石と同色なので，そのまま置く．
したがって，テーブル上の碁石は
○○●●○○○○
となる．
• 8 番目の碁石が黒（●）の場合は，右端の碁石（○）と色が異なるので，まず
テーブルの右端にある 3 個の連続した白い碁石（○）を取り除き，黒い碁石
（●）に置き換える．そして右端に 8 番目の碁石を置く．したがって，テーブル上の碁石は
○○●●●●●●
となる．
入力として置く碁石の順番が与えられたとき，n 個の碁石をならべ終わった後，
テーブル上に置いてある白い碁石の個数を求めるプログラムを作成せよ．

=================================================================
解説=============================================================
制約的にO(n)での解法があるのは自明（あんまこういう考えはダメだね)
がんばって場合などで考えると,
連続した各色の数を配列として持っておき,
例えば, 今見ている中で一番右端のindexを r_stoneとすれば
次に同じ色が並べば 配列[r_stone]をインクリメント
違う色がくれば, 奇数番目のときはr_stoneは次のindex(r_stone++)へ移動し,配列[r_stone]=1
　　　　　　　　偶数番目のときは 配列[r_stone-1] += 配列[r_stone] + 1 とすれば, 
		　　　一つ前の列(別の色の配列)を今の色として変換できることが分かる

最後に一番左端の色が何の色であるのかを記憶しておけば各配列には0~r_stone間の内部には
黒・白が交互にならんでその連続した色の数が記憶されているため、純粋に数え上げればよい
================================================================
*/
int main(void) {
	cin.tie(0); ios::sync_with_stdio(false);
	int n; cin >> n;
	int l_stone_c;
	int r_stone;
	int pre_stone_c;
	vector<int> stones(n, 0);
	for (int i = 0; i < n;i++) {
		int c; cin >> c;
		if (i == 0) {
			r_stone = 0;
			stones[i]++;
			l_stone_c = pre_stone_c = c;
			continue;
		}
		if (pre_stone_c == c) {
			stones[r_stone]++;
		}
		else {
			if (i % 2 == 1) {
				if (r_stone == 0) {
					stones[r_stone]++;
					l_stone_c = c;
				}
				else {
					stones[r_stone - 1] += stones[r_stone] + 1;
					r_stone--;
				}
			}
			else {
				r_stone++;
				stones[r_stone] = 1;
			}
		}
		pre_stone_c = c;
	}
	int res = 0;
	bool f;
	if (l_stone_c == 0) f = true;
	else f = false;
	for (int i = 0; i <= r_stone;i++) {
		if (f)res += stones[i];
		f = !f;
	}
	cout << res << endl;
	return 0;
}