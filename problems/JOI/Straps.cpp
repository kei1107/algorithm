#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
 <url:https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d4.pdf>
 問題文============================================================
 JOI 君は，携帯電話に取り付けるためのストラップを N 個持っている．
 ストラップには 1 から N までの番号が付けられている．
 JOI 君は，これらのストラップのうちいくつかを携帯電話に取り付けようとしている．
 JOI 君の持っているストラップは少し変わっていて，いくつかのストラップには，
 他のストラップを取り付けるための端子が何個か付いている．
 それぞれのストラップは，携帯電話に直接取り付けるか，あるいは他のストラップの端子に取り付けることができる．
 携帯電話に直接取り付けられるストラップは 1 個までである．
 また，それぞれのストラップには，取り付けたときに得られる嬉しさが決まっている．
 この嬉しさは 1つの整数で表される．JOI 君が嫌いなストラップもあり，その場合は嬉しさは負の値になる．
 JOI 君は，携帯電話につながっているストラップの嬉しさの総和を最大化したい．
 ただし，必ずしもすべての端子にストラップが取り付けられている必要はなく，
 ストラップを 1 つも取り付けなくてもかまわない．
 
 JOI 君の持っている N 個のストラップの情報が与えられる．
 適切にストラップを取り付けたとき，携帯電話につながっているストラップの嬉しさの総和の最大値を求めるプログラムを作成せよ．
 =================================================================
 解説=============================================================
 
 dp[i][j] := i番目まで見たとき、j個のストラップが連結可能の時の嬉しさ

 jはNより大きくなる必要がなく、初期状態はdp[0][1] = 0;
 それ以外は重複しない別の値にして、計算しないようにする
 
 ================================================================
 */
int main(void) {
    cin.tie(0); ios::sync_with_stdio(false);
    ll N; cin >> N;
    vector<pll> AB(N);
    for(auto &in:AB) cin >> in.first >> in.second;
    sort(AB.begin(),AB.end());
    reverse(AB.begin(),AB.end());
    vector<vector<ll>> dp(N+1,vector<ll>(N+1,-(LINF)));
    dp[0][1] = 0;
    for(int i = 0; i < N;i++){
        for(int j = 0; j <= N;j++){
           dp[i+1][j] = max(dp[i+1][j],dp[i][j]);
            if(j == 0) continue;
            dp[i+1][min(N,j+AB[i].first-1)] = max(dp[i+1][min(N,j+AB[i].first-1)],dp[i][j] + AB[i].second);
        }
    }
    ll res = 0;
    for(auto v:dp[N]) res = max(res,v);
    cout << res << endl;
    return 0;
}
