#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define INF 1<<30
#define LINF 1LL<<60

/*
 <url:https://joi2013ho.contest.atcoder.jp/img/other/joi2013ho/joi2013ho2.pdf>
 問題文============================================================
 
 IOI 国ではこのたび新たに鉄道を敷設した．
 IOI 国の鉄道を走る列車はいくつかの車両が連結されたものであり，車両には I, O の 2 種類がある．
 車両はそれぞれ異なる種類の車両としか連結できない．また，列車に運転席を設ける関係上，
 列車の両端の車両は種類 I でなければならない．列車は車両の種類を表す文字を順につなげた文字列で表され，
 列車の長さはその文字列の長さであるとする．たとえば， IOIOI の順に車両を連結すると長さ 5 の列車を編成でき，
 また車両 I は単独で長さ 1 の列車である．車両を OIOI やIOOI といった順に並べても列車を編成することはできない．
 いくつかの車両が 2 つの車庫に格納されている．それぞれの車庫の中には車両が一列に並んでいる．
 列車を編成するときは車庫から車両を出してきて車庫前で連結していく．
 車庫から出せる車両は最も車庫の入り口に近い車両のみであるが，
 どちらの車庫から車両を出すかの順番については自由である．
 列車を編成する前に，車両を好きなだけ車庫から出して別の待機用レールに移すことができる．
 一度待機用レールに移した車両は今後列車を編成するために使うことはできない．
 また，一度列車の編成を始めるとその編成が終わるまでの間は車両を車庫から待機用レールに移すことはできない．
 列車を編成するとき，車庫内の全ての車両を使い切る必要はない．
 すなわち，列車の編成を終えた後，車庫内に使われなかった車両が残っていても構わない．
 IOI 国では鉄道に乗る人がとてもたくさんいると考えられているので，できるだけ長い列車を編成したい．
 
 車庫に格納された車両の情報が与えられたとき，編成できる列車の長さの最大値を求めるプログラムを作成せよ．
 それぞれの車庫に格納された車両の列は 2 種類の文字 I, O のみからなる文字列で表され，
 2 つの車庫の情報はそれぞれ長さ M の文字列 S および長さ N の文字列 T として与えられる．
 各文字が 1 つの車両を表し，その文字は車両の種類と同じである．
 文字列の 1 文字目は最も車庫の入り口に近い車両を表し，末尾の文字が車庫の最も奥にある車両を表す．
 
 1 <= M <= 2 000 文字列 S の長さ
 1 <= N <= 2 000 文字列 T の長さ
 
 =================================================================
 解説=============================================================
 
 dp[i][j][k] := Sのi文字目, Tのj文字目, 列車の最後の文字がk(0:O, 1:I)の時の最大の長さ
 
 片方の列車が全て取り除かれた場合(i == M or j == N)についての考慮を怠り沼ってしまった
 ================================================================
 */

ll dp[2005][2005][2];
int main(void) {
    cin.tie(0); ios::sync_with_stdio(false);
    ll M,N; cin >> M >> N;
    string S,T; cin  >> S >> T;
    for(int i = 0;i  < 2005;i++)for(int j = 0; j < 2005;j++) dp[i][j][1] = -(INF);
    for(int i = 0; i <= M; i++)for(int j = 0; j <= N;j++) dp[i][j][0] = 0;
    
    ll ans = 0;
    for(int i = 0; i <= M;i++){
        for(int j = 0; j <= N;j++){
            for(int k = 0; k < 2;k++){
                if(k == 0){
                    if(S[i] == 'I') dp[i+1][j][1] = max(dp[i+1][j][1],dp[i][j][k] + 1);
                    if(T[j] == 'I') dp[i][j+1][1] = max(dp[i][j+1][1],dp[i][j][k] + 1);
                }else{
                    if(S[i] == 'O')dp[i+1][j][0] = max(dp[i+1][j][0],dp[i][j][k] + 1);
                    if(T[j] == 'O')dp[i][j+1][0] = max(dp[i][j+1][0],dp[i][j][k] + 1);
                    ans = max(ans,dp[i][j][k]);
                }
            }
        }
    }
    cout << ans << endl;
    return 0;
}
