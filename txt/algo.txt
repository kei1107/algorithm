 operator<(const node &leftNode, const node &rightNode) {
 if (leftNode.cost != rightNode.cost) return leftNode.cost < rightNode.cost;
 if (leftNode.at != rightNode.at) return leftNode.at < rightNode.at;
 return false;
}

**************************************************************************************

typedef int Weight;
struct Edge {
  int src, dst;
  Weight weight;
  Edge(int src, int dst, Weight weight) :
    src(src), dst(dst), weight(weight) { }
};
bool operator < (const Edge &e, const Edge &f) {
  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!
    e.src != f.src ? e.src < f.src : e.dst < f.dst;
}
typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

typedef vector<Weight> Array;
typedef vector<Array> Matrix;

**************************************************************************************

const int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};
const int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};


**************************************************************************************
約数　総列挙

vector<ll> getDivisor(ll n) {
	vector<ll> v;
	for (int i = 1; i * i <= n;i++) {
		if (n % i == 0) {
			v.push_back(i);
			if (i != n / i) {
				v.push_back(n / i);
			}
		}
	}
	sort(v.begin(), v.end());
	return v;
}

**************************************************************************************
桁数

unsigned GetDigit(unsigned num) {
	return std::to_string(num).length();
}

**************************************************************************************
パスカルの3角形（組合せ）

const int MAX_C = 1100;
double Com[MAX_C][MAX_C];
 
void calc_com() {
    for (int i = 0; i < MAX_C; ++i) for (int j = 0; j < MAX_C; ++j) Com[i][j] = 0.0;
    Com[0][0] = 1.0;
    for (int i = 1; i < MAX_C; ++i) {
        Com[i][0] = 1.0;
        for (int j = 1; j < MAX_C; ++j) {
            Com[i][j] = (Com[i-1][j-1] + Com[i-1][j]);
        }
    }
}



※確率

  FOR(i, 0, MAX_N)FOR(j, 0, MAX_N)comb[i][j] = 0;

    comb[0][0] = 1;

    FOR(i, 1, MAX_N) {
        comb[i][0] = comb[i - 1][0]/2;
        FOR(j, 1, MAX_N) {
            comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) / 2;
        }
    }

*************************************************************************************

#define MOD 1000000007

//繰り返し2乗法
#define ll long long
ll powmod(ll x, ll n, ll mod) {
    ll res = 1;
    while (n > 0) {
        if (n & 1) {
            res =(res*x)%mod;
        }
        x = (x*x)%mod;
        n >>= 1;
    }
    return res;
}


const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}

*******************************************************************************************************

int countbit(int n) {
    int ret = 0;
    while (n) {
        n &= n - 1;
        ++ret;
    }
    return ret;
}


*---------------------------------------------------------------------------------------------------------------------*

幅優先探索

function 幅優先探索(v)
    v に訪問済みの印を付ける
    v をキューに追加
    while キューに要素を含む do
        v ← キューから取り出す
        v を処理
        for each v に接続している頂点 i do
            if i が未訪問 then
                i に訪問済みの印を付ける
                i をキューに追加
                
                


#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
#include <string.h>
using namespace std;
queue<int> q;
vector<vector<int> > v(101);
int dp[101];
int n, t = 0;
int main() {
    cin >> n;
    for (int i = 0; i < n;i++) {
        int u, k; cin >> u >> k;
        for (int j = 0; j < k;j++) {
            int x; cin >> x;
            v[u].push_back(x);
        }
    }
    memset(dp, -1, sizeof(dp));
    q.push(1); dp[1] = 0;
    while (!q.empty()) {
        int a = q.front(); q.pop();
        for (int i = 0; i < v[a].size();i++) {
            if (dp[v[a][i]] == -1) {
                dp[v[a][i]] = dp[a] + 1;
                q.push(v[a][i]);
            }
        }
    }
    for (int i = 1; i <= n;i++) {
        cout << i << " " << dp[i] << endl;
    }
}


*---------------------------------------------------------------------------------------------------------------------*

深さ優先探索

function 深さ優先探索(v)
    v に訪問済みの印を付ける
    v を処理する
    for each v に接続している頂点 i do
        if i が未訪問 then
            深さ優先探索(i)
            
            

function 深さ優先探索(v)
    S ← 空のスタック
    v に訪問済みの印を付ける
    v を S に積む
    while S が空ではない do
        v ← S から取り出す
        v を処理する
        for each v に接続している頂点 i do
            if i が未訪問 then
                i に訪問済みの印を付ける
                i を S に積む


#include <iostream>
#include <vector>
using namespace std;
vector<vector<int> > v(101);
int dp[101][2] = { 0 };
int n, t = 0;
 
void dfs(int a) {
    if (dp[a][0] == 0) { t++; dp[a][0] = t; }
    else { return; }
    for (int i = 0;i < v[a].size();i++) {
        if (dp[v[a][i]][0] == 0) {
            dfs(v[a][i]);
        }
    }
    if (dp[a][1] == 0) { t++; dp[a][1] = t; }
}
 
int main() {
    cin >> n;
    for (int i = 0; i < n;i++) {
        int u,k; cin >> u >> k;
        for (int j = 0; j < k;j++) {
            int x; cin >> x;
            v[u].push_back(x);
        }
    }
    for (int i = 1; i <= n;i++) {
        dfs(i);
    }
    for (int i = 1; i <= n;i++) {
        cout << i << ' ' << dp[i][0] << ' ' << dp[i][1] << endl;
    }
}


*---------------------------------------------------------------------------------------------------------------------*

ダイクストラ

https://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95



#include <iostream>
#include <vector>
#include <map>
#include <queue>
#include <algorithm>
#define INF 1<<30
using namespace std;
int main() {
    cin.tie(0);ios::sync_with_stdio(false);
    int V, E, r; cin >> V >> E >> r;
    vector<vector<pair<int,int>>> g(V);
    vector<int> dp(V);
    queue<int> q;
 
    //input
    int s, t, d;
    for (int i = 0; i < E; i++) {
        cin >> s >> t >> d;
        g[s].push_back(make_pair(t, d));
    }
 
    //initialize
    fill(dp.begin(), dp.end(), INF);
    dp[r] = 0;
    q.push(r);
 
    //Dijkstra
    while (!q.empty()) {
        int k = q.front(); q.pop();
        for (int i = 0; i < g[k].size();i++) {
            int next = g[k][i].first;
            int w = g[k][i].second;
            if (dp[k] + w < dp[next]) {
                dp[next] = dp[k] + w;
                q.push(next);
            }
        }
    }
 
    //output
    for (int i = 0; i < V;i++) {
        if (dp[i] == INF) { cout << "INF" << endl; }
        else { cout << dp[i] << endl; }
    }
}



*----------------------------------------------------------------------------------------------------------------------*
ベルマンフォード法

#include <iostream>
#include <vector>
#define INF 2147483647
using namespace std;
struct Edge {
    int to, cost;
    Edge(int to, int cost) : to(to), cost(cost) {}
};
typedef vector<vector<Edge> > P;
P graph;
vector<int> dist;
bool bellman_ford(int n, int s) {
    dist = vector<int>(n, INF);dist[s] = 0;
    for (int i = 0; i < n; i++) {
    	
    	//追加　　　dist[i] == INF  ⇒　continue?
    	
        for (int v = 0; v < n; v++) {
            for (int k = 0; k < graph[v].size(); k++) {
                Edge e = graph[v][k];
                if (dist[v] != INF && dist[e.to] > dist[v] + e.cost) {
                    dist[e.to] = dist[v] + e.cost;
                    if (i == n - 1) return true;
                    
                    // 原理的に一回も更新されなかったらそこでbreak可能
                    //下部、最小費用法にて同手法利用
                }
            }
        }
    }
    return false;
}
 
int main() {
    cin.tie(0); ios::sync_with_stdio(false);
    int V, E;cin >> V >> E;
    graph = P(V);
    for (int i = 0; i < E; i++) {
        int from, to, cost;cin >> from >> to >> cost;
        graph[from].push_back(Edge(to, cost));
    }
    for (int j = 0; j < V;j++) {
        if (bellman_ford(V, j)) { cout << "NEGATIVE CYCLE" << endl; return 0; }
        for (int i = 0; i < V; i++) {
            if (dist[i] != INF) { cout << dist[i]; }
            else { cout << "INF"; }
            if (i != V - 1) { cout << ' '; }
        }
        cout << endl;
    }
    return 0;
}



/閉路探索？　ベルマンフォード版


#include <iostream>
#include <vector>
#define INF 2147483647
using namespace std;
struct Edge {
	int to, cost;
	Edge(int to, int cost = -1) : to(to), cost(cost) {}
};
typedef vector<vector<Edge> > P;
P graph;
vector<int> dist;

bool bellman_ford(int n, int s) {
	dist = vector<int>(n, 0);
	for (int i = 0; i < n; i++) {
		for (int v = 0; v < n; v++) {
			for (int k = 0; k < graph[v].size(); k++) {
				Edge e = graph[v][k];
				if (dist[e.to] > dist[v] + e.cost) {
					dist[e.to] = dist[v] + e.cost;
					if (i == n - 1) return true;
				}
			}
		}
	}
	return false;
}

int main() {
	cin.tie(0); ios::sync_with_stdio(false);
	int V, E;cin >> V >> E;
	graph = P(V);
	for (int i = 0; i < E; i++) {
		int from, to;cin >> from >> to;
		graph[from].push_back(Edge(to));
	}

	if (bellman_ford(V, 0)) { cout << 1 << endl; }
	else { cout << 0 << endl; }
	return 0;
}

*-----------------------------------------------------------------------------------------------------*

ワーシャルフロイド

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef vector<vector<int> > Matrix;

const int INF = 1000000000;
Matrix d; // グラフの距離を格納した2次元配列（隣接行列）
          // d[u][v]は辺e=(u,v)のコスト（辺が存在しない場合はINF、ただしd[i][i]=0）

void warshall_floyd(int n) { // nは頂点数
  for (int i = 0; i < n; i++)      // 経由する頂点
    for (int j = 0; j < n; j++)    // 開始頂点
      for (int k = 0; k < n; k++)  // 終端
        d[j][k] = min(d[j][k], d[j][i] + d[i][k]);
}

int main() {
  int n, m;
  cin >> n;

  d = Matrix(n, vector<int>(n, INF));
  for (int i = 0; i < n; i++) d[i][i] = 0;
  
  cin >> m;
  for (int i = 0; i < m; i++) {
    int from, to, cost;
    cin >> from >> to >> cost;
    d[from][to] = cost;
  }
  
  warshall_floyd(n);
  
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      if (i != j && d[i][j] != INF)
        cout << i << "から" << j << "へのコスト: " << d[i][j] << endl;
    }
  }
  
  return 0;
}

*---------------------------------------------------------------------------------------------------------------------*
*
最小全域木

クラスカル法

foreach 辺e in E in ascending order
  if 採用した辺集合にeを加えても閉路を作らない then eを採用
return 採用した辺のコストの和



Union find  1

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;


struct UnionFind {
  vector<int> data;
  UnionFind(int size) : data(size, -1) { }
  bool unionSet(int x, int y) {
    x = root(x); y = root(y);
    if (x != y) {
      if (data[y] < data[x]) swap(x, y);
      data[x] += data[y]; data[y] = x;
    }
    return x != y;
  }
  bool findSet(int x, int y) {
    return root(x) == root(y);
  }
  int root(int x) {
    return data[x] < 0 ? x : data[x] = root(data[x]);
  }
  int size(int x) {
    return -data[root(x)];
  }
};


Union find 2

#include <iostream>
#include <vector>
using namespace std;
#define rep(i,n) for (int i=0; i < int(n); i++)

// 素集合データ構造
struct UnionFind
{
  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである
  vector<int> par;
  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる
  vector<int> sizes;

  UnionFind(int n) : par(n), sizes(n, 1) {
    // 最初は全てのデータiがグループiに存在するものとして初期化
    rep(i,n) par[i] = i;
  }

  // データxが属する木の根を得る
  int find(int x) {
    if (x == par[x]) return x;
    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す
  }

  // 2つのデータx, yが属する木をマージする
  void unite(int x, int y) {
    // データの根ノードを得る
    x = find(x);
    y = find(y);

    // 既に同じ木に属しているならマージしない
    if (x == y) return;

    // xの木がyの木より大きくなるようにする
    if (sizes[x] < sizes[y]) swap(x, y);

    // xがyの親になるように連結する
    par[y] = x;
    sizes[x] += sizes[y];
    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい
  }

  // 2つのデータx, yが属する木が同じならtrueを返す
  bool same(int x, int y) {
    return find(x) == find(y);
  }

  // データxが含まれる木の大きさを返す
  int size(int x) {
    return sizes[find(x)];
  }
};




struct UnionFind {
    vector<int> par;
    int n, cnt;
    UnionFind(const int& x = 0) {init(x);}
    void init(const int& x) {par.assign(cnt=n=x, -1);}
    inline int find(const int& x) {return par[x] < 0 ? x : par[x] = find(par[x]);}
    inline bool same(const int& x, const int& y) {return find(x) == find(y);}
    inline bool unite(int x, int y) {
        if ((x = find(x)) == (y = find(y))) return false;
        --cnt;
        if (par[x] > par[y]) swap(x, y);
        par[x] += par[y];
        par[y] = x;
        return true;
    }
    inline int count() const {return cnt;}
    inline int count(int x) {return -par[find(x)];}
};

*本実装**************************************************

Unionfind2（利用)

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
#define rep(i,n) for (int i=0; i < int(n); i++)


// 素集合データ構造
struct UnionFind
{
  /* 略 */
};


// 頂点a, bをつなぐコストcostの（無向）辺
struct Edge
{
  int a, b, cost;

  // コストの大小で順序定義
  bool operator<(const Edge& o) const {
    return cost < o.cost;
  }
};

// 頂点数と辺集合の組として定義したグラフ
struct Graph
{
  int n;  // 頂点数
  vector<Edge> es;  // 辺集合

  // クラスカル法で無向最小全域木のコストの和を計算する
  // グラフが非連結のときは最小全域森のコストの和となる
  int kruskal() {
    // コストが小さい順にソート
    sort(es.begin(), es.end());

    UnionFind uf(n);
    int min_cost = 0;

    rep(ei, es.size()) {
      Edge& e = es[ei];
      if (!uf.same(e.a, e.b)) {
        // 辺を追加しても閉路ができないなら、その辺を採用する
        min_cost += e.cost;
        uf.unite(e.a, e.b);
      }
    }

    return min_cost;
  }
};

// 標準入力からグラフを読み込む
Graph input_graph() {
  Graph g;
  int m;
  cin >> g.n >> m;
  rep(i, m) {
    Edge e;
    cin >> e.a >> e.b >> e.cost;
    g.es.push_back(e);
  }
  return g;
}


int main()
{
  Graph g = input_graph();
  cout << "最小全域木のコスト: " << g.kruskal() << endl;
  return 0;
}
*------------------------------------------------------------------------------------------------------------------*
最小費用流

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

#define rep(i,n) for (int i=0;i<(n);i++)
#define rep2(i,a,b) for (int i=(a);i<(b);i++)
#define rrep(i,n) for (int i=(n)-1;i>=0;i--)
#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)
#define all(a) (a).begin(),(a).end()

typedef long long ll;
typedef pair<int, int> P;
typedef vector<int> vi;
typedef vector<P> vp;
typedef vector<ll> vll;

const int INF = 99999999;
const int MAX_V = 100000;

struct edge {
	int to, cap, cost, rev;
	edge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}
};
int V, E, F;
vector<edge> G[MAX_V];
int dist[MAX_V];
int prevv[MAX_V], preve[MAX_V]; // privious vertex, edge

void add_edge(int from, int to, int cap, int cost) {
	G[from].emplace_back(edge(to, cap, cost, (int)G[to].size() ));
	G[to].emplace_back(edge(from, 0, -cost, (int)G[from].size() - 1 ));
}

// get min cost flow from s to t
// if we can flow not at all, then return -1
int min_cost_flow(int s, int t, int f) {
	int res = 0;
	while (f > 0) {
		fill(dist, dist + V, INF);
		dist[s] = 0;
		bool update = true;
		while (update) {
			update = false;
			rep(v, V) {
				if (dist[v] == INF) continue;
				rep(i, G[v].size()) {
					edge &e = G[v][i];
					if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {
						dist[e.to] = dist[v] + e.cost;
						prevv[e.to] = v;
						preve[e.to] = i;
						update = true;
					}
				}
			}
		}

		if (dist[t] == INF) {
			// no more flow
			return -1;
		}

		// flow as much as possible along minimum path from s to t
		int d = f;
		for (int v = t; v != s; v = prevv[v]) {
			d = min(d, (int)G[prevv[v]][preve[v]].cap);
		}

		f -= d;
		res += d * dist[t];
		for (int v = t; v != s; v = prevv[v]) {
			edge &e = G[prevv[v]][preve[v]];
			e.cap -= d;
			G[v][e.rev].cap += d;
		}
	}
	return res;
}

signed main() {
	cin >> V >> E >> F;
	rep(i, E) {
		int u, v, c, d;
		cin >> u >> v >> c >> d;
		add_edge(u, v, c, d);
	}

	cout << min_cost_flow(0, V - 1, F) << endl;
}

*----------------------------------------------------------------------------------------------------------*
最大流

#include <iostream>
#include <vector>
#include <queue>
#define INF (1 << 30)
using namespace std;
bool bfs(vector<vector<int>>& Graph,int s,int t,vector<int>& parent) {
    vector<bool> visited(t + 1, false);
    queue<int> q;
    q.push(s); visited[s] = true; parent[s] = -1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v = 0; v < t+1;v++) {
            if (visited[v] == false && Graph[u][v] > 0) {
                q.push(v);  parent[v] = u;  visited[v] = true;
            }
        }
    }
    return (visited[t] == true);
}
int fordFulkerson(vector<vector<int>>& Graph, int s, int t) { 
    int u, v;
    vector<int> parent(t + 1);
    int max_flow = 0;
    while (bfs(Graph, s, t, parent)) {
        int path_flow = INF;
        for (v = t; v != s; v = parent[v]) {
            u = parent[v];  path_flow = min(path_flow, Graph[u][v]);
        }
 
        for (v = t; v != s; v = parent[v]) {
            u = parent[v];
            Graph[u][v] -= path_flow;
            Graph[v][u] += path_flow;
        }
 
        max_flow += path_flow;
    }
    return max_flow;
}
int main() {
    int V, E; cin >> V >> E;
    vector<vector<int>> G(V,vector<int>(V,0));    //V x V   init:0
    for (int i = 0; i < E;i++) {
        int u, v, c; cin >> u >> v >> c;
        G[u][v] = c;
    }
    cout << fordFulkerson(G, 0, V - 1) << endl;
    return 0;
}










#include <iostream>
#include <vector>
#include <queue>
#define INF (1 << 30)
using namespace std;
struct Edge {
	//to : Edge(from → to)   cap:capacity	cost:cost	rev:reverse
	int to, cap, cost, rev;
	Edge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}
};

#define P vector<vector<Edge>>
vector<int> dist;
bool bellman_ford(P& Graph, int s, int t, vector<int>& parent_v, vector<int>& parent_at) {
	dist = vector<int>(t + 1, INF);
	dist[s] = 0;
	for (int i = 0; i <= t;i++) {
		for (int v = 0; v <= t;v++) {
			if (dist[v] == INF)continue;
			for (int at = 0; at < Graph[v].size();at++) {
				Edge &e = Graph[v][at];
				if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {
					//cout << i << " " << v << endl;
					dist[e.to] = dist[v] + e.cost;
					parent_v[e.to] = v;
					parent_at[e.to] = at;
					if (i == t) return false;
				}
			}
		}
	}
	return true;
}

int primal_dual(P& Graph, int s, int t, int F) {
	vector<int> parent_v(t + 1);
	vector<int> parent_at(t + 1);
	int min_cost_flow = 0;
	while (bellman_ford(Graph, s, t, parent_v, parent_at)) {
/*
		for (int i : dist) {
			cout << i << " ";
		}
		cout << endl;
*/
		if (dist[t] == INF) { return -1; }
		int path_flow = F;
		for (int v = t; v != s; v = parent_v[v]) {
			path_flow = min(path_flow, Graph[parent_v[v]][parent_at[v]].cap);
		}

		F -= path_flow;
		min_cost_flow += path_flow*dist[t];

		if (F == 0) { return min_cost_flow; }
		if (F < 0) { return -1; }

		for (int v = t; v != s; v = parent_v[v]) {
			Edge & e = Graph[parent_v[v]][parent_at[v]];
			e.cap -= path_flow;
			Graph[v][e.rev].cap += path_flow;
		}
	}
	return min_cost_flow;
}
int main() {
	int V, E, F; cin >> V >> E >> F;
	P G(V);
	for (int i = 0; i < E;i++) {
		int u, v, c, d; cin >> u >> v >> c >> d;
		G[u].emplace_back(Edge(v, c, d, G[v].size()));
		G[v].emplace_back(Edge(u, 0, -d, G[u].size() - 1));
	}

/*
	for (int i = 0; i < V;i++) {
		for (int j = 0; j < G[i].size();j++) {
			cout << G[i][j].cap << ":" << G[i][j].cost << " ";
		}
		cout << endl;
	}
*/

	cout << primal_dual(G, 0, V - 1, F) << endl;
	return 0;
}












int N, g, E;

int ans = 0LL;

#define MAX_V 130
struct edge {
    int to; int cap; int rev;
};
vector<edge> G[MAX_V];

bool used[MAX_V];

void add_edge(int from, int to, int cap) {
    G[from].push_back((edge) { to, cap, (int)G[to].size() });
    G[to].push_back((edge) { from, 0, (int)G[from].size() - 1 });
}

int dfs(int v, int t, int f) {
    if (v == t)return f;
    used[v] = true;

    FOR(i, 0, (int)G[v].size()) {
        edge &e = G[v][i];
        if (!used[e.to] && e.cap > 0) {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d > 0) {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t) {
    int flow = 0;
    for (;;) {
        memset(used, 0, sizeof(used));
        int f = dfs(s, t, INF);
        if (f == 0)return flow;
        flow += f;
    }
    return -1;
}


int main()
{
    cin.tie(0);
    ios_base::sync_with_stdio(false);

    cin >> N >> g >> E;
    FOR(i, 0, g) {
        int a; cin >> a;
        add_edge(a, N, 1);
    }

    FOR(i, 0, E) {
        int a, b;
        cin >> a >> b;
        add_edge(a, b, 1);
        add_edge(b, a, 1);
    }
    ans = max_flow(0, N);
    cout << ans << endl;

    return 0;
}

*************************************************************************************************************

LCA 


#include <iostream>
#include <vector>
#include <map>
#include <string.h>
#include <algorithm>
#define P pair<int,int>
#define INF (1<<30)
using namespace std;

vector<int> Ind(100010);		//Ind[n]  接点nがeuler tour木で現れる数を保存
vector<bool> f(100010, false);	//
vector<vector<int>> T(100010);	//グラフ
vector<P> ET;                   //二分探索木    [深さ,頂点番号]


void dfs(int n,int dep) {
	f[n] = true;
	ET.emplace_back(make_pair(dep,n));
	Ind[n] = ET.size() - 1;
	for (int next : T[n]) {
		if (f[next] == true) continue;
		dfs(next,dep + 1);
		ET.emplace_back(make_pair(dep,n));
	}
}

P RMQ(int a, int b, int k, int l, int r, vector<P>& node) {
	if (r <= a || b <= l) {return P(INF, INF); }
	if (a <= l && r <= b) return node[k];

	P vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);
	P vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r, node);
	return min(vl, vr);
}

int main() {
	cin.tie(0); ios::sync_with_stdio(false);
	//Graph initialize
	int n_; cin >> n_;
	for (int i = 0; i < n_; i++) {
		int k; cin >> k;
		for (int j = 0; j < k; j++) {
			int c; cin >> c;
			T[i].emplace_back(c);
			T[c].emplace_back(i);
		}
	}
	//ET木の生成
	dfs(0,0);

	//RMQ initialize
	n_ = ET.size();

	int n = 1;
	while (n < n_) n *= 2;
	vector<P> node(2 * n - 1, P(INF, INF));

	for (int i = 0; i < n_;i++) { node[n - 1 + i] = ET[i]; }
	for (int i = n - 2; i >= 0; i--) { node[i] = min(node[2 * i + 1], node[2 * i + 2]); }

	//Answer
	int q; cin >> q;
	for (int i = 0; i < q; i++) {
		int u, v; cin >> u >> v;
		int a = Ind[u], b = Ind[v];
		if (a > b) { swap(a, b); }
		if (a == b) { cout << u << endl; continue; }
		cout << RMQ(a,b+1, 0, 0, n, node).second << endl;
		//AOJ前後差が１しかない、問題の性質からbでも成り立つ
	}
}

****************************************************************************************
RMQのみ

#include <iostream>
#include <climits>
#include <vector>
#include <algorithm>
using namespace std;

void update(int i,int x,vector<int>& node,int n) {
	i += n - 1;
	node[i] = x;
	while ( i > 0) {
		i = (i - 1) / 2;
		node[i] = min(node[2 * i + 1], node[2 * i + 2]);
	}
}
int find(int a,int b,int k,int l,int r, vector<int>& node) {
	if (r <= a || b <= l)return INT_MAX;
	if (a <= l && r <= b) return node[k];
	else {
		int vl = find(a, b, 2 * k + 1, l, (l + r) / 2, node);
		int vr = find(a, b, 2 * k + 2, (l + r) / 2, r, node);
		return min(vl, vr);
	}
}


int main() {
	cin.tie(0); ios::sync_with_stdio(false);
	int n_, q;  cin >> n_ >> q;
	int n = 1;
	while (n < n_) n *= 2;
	vector<int> node(2 * n - 1, INT_MAX);

	for (int i = 0; i < q; i++) {
		int com, x, y; cin >> com >> x >> y;
		if (com == 0) { update(x, y, node, n); }
		else {
			// 閉区間、開区間の違いから　y + 1
			cout << find(x, y+1 , 0, 0, n, node) << endl;
		}
	}
}


struct SegTree {
	using type = int; 	type INIT_VAL = INT_MAX; type merge(type a, type b) {return min(a, b); } int N; vector<type> dat;
	SegTree(int _N) {N = 1;	while (N < _N)N *= 2;dat = vector<type>(N * 2 - 1, INIT_VAL);}
	void update(int k, type val) {k += N - 1; dat[k] = val;	while (k) { k = (k - 1) / 2; dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);}}
	type query(int a, int b, int k, int l, int r) {if (r <= a || b <= l)return INIT_VAL; if (a <= l&&b >= r)return dat[k];
		type v1 = query(a, b, k * 2 + 1, l, (l + r) / 2); type v2 = query(a, b, k * 2 + 2, (l + r) / 2, r);	return merge(v1, v2); }
	inline type query(int a, int b) {return query(a, b, 0, 0, N);}
};
**************************************************************************************************************
RSQ

int bit[N + 1];

//BITは 1-indexed で扱います!!!! [1, N] 区間を配列の添字として扱うときに注意.
void add(int x, int val)
{
    while (x <= N){
        bit[x] += val;
        x += x & -x;
    }
}

int sum(int x)
{
    int ret = 0;
    while (x){
        ret += bit[x];
        x &= (x - 1);
    }
    
    return (ret);
}




#include <iostream>
#include <climits>
#include <vector>
#include <algorithm>
using namespace std;
 
void add(int i, int x, vector<int>& node, int n) {
    i += n - 1;
    node[i] += x;
    while (i > 0) {
        i = (i - 1) / 2;
        node[i] = node[2 * i + 1] +node[2 * i + 2];
    }
}
int getSum(int a, int b, int k, int l, int r, vector<int>& node) {
    if (r <= a || b <= l) return 0;
    if (a <= l && r <= b) return node[k];
    return (getSum(a, b, 2*k+1 , l, (l + r)/2, node) + getSum(a, b, 2*k + 2 , (l + r)/2, r, node));
}
 
 
int main() {
    cin.tie(0); ios::sync_with_stdio(false);
    int n_, q;  cin >> n_ >> q;
    int n = 1;
    while (n < n_) n *= 2;
    vector<int> node(2 * n - 1, 0);
 
    for (int i = 0; i < q; i++) {
        int com, x, y; cin >> com >> x >> y;
        if (com == 0) { add(x - 1, y, node, n); }
        else { cout << getSum(x - 1, y, 0, 0, n, node) << endl; }
    }
}

*-----------------------------------------------------------------------------------------------*
最長増加部分列

#include <iostream>
#include <vector>
#include <algorithm>
#define INF (1<<30)
using namespace std;
 
int main() {
    cin.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n;i++) {
        cin >> a[i];
    }
    int ans = 0;
    vector<int> dp(n + 1, 0);
    /*
    //  O(n^2) TLE
    //  dp[i] = a[i]???????????????????´???¨????????¨???????¢??????¨??????????????§???
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
        for (int j = 0; j < i;j++) {
            if (a[j] < a[i])
                dp[i] = max(dp[i], dp[j] + 1);
        }
        ans = max(ans, dp[i]);
    }
    */
    //  O(nlogn)
    fill(dp.begin(), dp.end(), INF);
    for (int i = 0; i < n;i++) {
        *lower_bound(dp.begin(), dp.end(), a[i]) = a[i];
    }
    ans = distance(dp.begin(), lower_bound(dp.begin(), dp.end(), INF));
    cout << ans << endl;
}

****************************************************************************************************

いもす法

#include <iostream>
#include <algorithm>
using namespace std;

int imos[1000005];

int main() {
	cin.tie(0); ios::sync_with_stdio(false);
	int n; cin >> n;
	for (int i = 0; i < n;i++) {
		int a, b; cin >> a >> b;
		imos[a]++; imos[b + 1]--;
	}
	int ans = imos[0];
	for (int i = 1;i < 1000001;i++) {
		imos[i] += imos[i - 1];
		ans = max(ans, imos[i]);
	}
	cout << ans << endl;
	
}


**********************************************************************************************

桁dp

template < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };

for ( int d = 0; d <= ( j ? 9 : D ); ++d )

dp[ i + 1 ][ j || ( d < D ) ] += dp[ i ][ j ];




for ( int i = 0; i < L; ++i )
	{
		const int D = S[i] - '0';

		for ( int j = 0; j < 2; ++j )
		{
			for ( int k = 0; k < 2; ++k )
			{
				for ( int d = 0; d <= ( j ? 9 : D ); ++d )
				{
					dp[ i + 1 ][ j || ( d < D ) ][ k || d == 4 || d== 9 ] += dp[i][j][k];
				}
			}
		}
	}

***********************************************************************************************
文字列での k mod C

int k_mod_C = 0;
		rep(i, k.size())
		{
			k_mod_C = (k_mod_C * 10 + (k[i] - '0')) % C;
		}
		
		

template <class String>
ll modstr(const String &s, ll m) {
    ll a = 0;
    for (auto &c : s) a = (c - '0' + a * 10) % m;
    return a;
}

*********************************************************************************************

しゃくとり法

#include <iostream>
#include <vector>
#include <climits>
using namespace std;
int main() {
    cin.tie(0); ios::sync_with_stdio(false);
    long long N, S; cin >> N >> S;
    vector<long long> Sum(N + 1,0);
    for (int i = 1; i <= N;i++) {
        int a; cin >> a;
        Sum[i] += Sum[i - 1] + a;
    }
    long long ans = LLONG_MAX;
    int left = 0, right = 0;
    while (true) {
        if (Sum[right] - Sum[left] >= S) {
            ans = (ans < right - left) ? ans : right - left;
            left++;
        }
        else right++;
        if (right > N || left > N) { if (ans == LLONG_MAX)ans = 0; cout << ans << endl; return 0; }
    }
}

***************************************************************************************************
kDtree

#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
 
struct Node {
    int location;
    int p, l, r;
    Node() {}
};
 
struct Point {
    int x;
    int y;
    int index;
    Point() {}
    Point(int x, int y, int index) :x(x), y(y), index(index) {}
    bool operator < (const Point& o) const {
        return index < o.index;
    }
};
static const int MAX = 1000000;
static const int NIL = -1;
Point P[MAX];
Node T[MAX];
int N;
int np;
 
bool lessX(const Point &p1, const Point &p2) {
    return p1.x < p2.x;
}
 
bool lessY(const Point &p1, const Point &p2) {
    return p1.y < p2.y;
}
 
int makekDTree(int l, int r, int depth) {
    if (!(l < r))return NIL;
    int mid = (l + r) / 2;
    int t = np++;
    if (depth % 2 == 0) {
        sort(P + l, P + r, lessX);
    }
    else {
        sort(P + l, P + r, lessY);
    }
    T[t].location = mid;
    T[t].l = makekDTree(l, mid, depth + 1);
    T[t].r = makekDTree(mid + 1, r, depth + 1);
 
    return t;
}
 
void find(int v, int sx, int tx, int sy, int ty, int depth, vector<Point> &ans) {
    int x = P[T[v].location].x;
    int y = P[T[v].location].y;
 
    if (sx <= x && x <= tx && sy <= y && y <= ty) {
        ans.push_back(P[T[v].location]);
    }
 
    if (depth % 2 == 0) {
        if (T[v].l != NIL) {
            if (sx <= x) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);
        }
        if (T[v].r != NIL) {
            if (x <= tx) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);
        }
    }
    else {
        if (T[v].l != NIL) {
            if (sy <= y) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);
        }
        if (T[v].r != NIL) {
            if (y <= ty) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);
        }
    }
}
 
int main() {
    scanf("%d", &N);
    for (int i = 0; i < N;i++) {
        int x, y; scanf("%d %d", &x, &y);
        P[i] = Point(x, y, i);
        T[i].l = T[i].r = T[i].p = NIL;
    }
    np = 0;
    int root = makekDTree(0, N, 0);
    int q; scanf("%d", &q);
    vector<Point> ans;
    for (int i = 0; i < q; i++) {
        int sx, tx, sy, ty; scanf("%d %d %d %d", &sx, &tx, &sy, &ty);
        ans.clear();
        find(root, sx, tx, sy, ty, 0, ans);
        sort(ans.begin(), ans.end());
        for (auto& p : ans) {
            printf("%d\n", p.index);
        }
        printf("\n");
    }
    return 0;
}

**********************************************************************************************************



#define ll long long
inline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
inline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }
