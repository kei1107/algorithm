#include <bits/stdc++.h>


http://dai1741.github.io/maximum-algo-2012/cpp/geometry/geometries2d.h
*************************************************************************************

#include <string>
#include <sstream>

using namespace std;

//conversion
//------------------------------------------
inline int toInt(std::string s) {int v; std::istringstream sin(s);sin>>v;return v;}
template<class T> inline std::string toString(T x) {std::ostringstream sout;sout<<x;return sout.str();}

↑
関数に使う場合はconst が必要な場合あり
**************************************************************************************
http://torus711.hatenablog.com/entry/20150423/1429794075
桁dp
for ( int d = 0; d <= ( j ? 9 : D ); ++d )
↓
dp[ i + 1 ][ j || ( d < D ) ] += dp[ i ][ j ];

dp[ 決めた桁数 ][ 未満フラグ ] := 総数



fill( ( long long * )dp, ( long long * )dp + sizeof( dp ) / sizeof( long long ), 0 );
***************************************************************************************************

#include <bits/stdc++.h>

#include <iostream>

using namespace std;
int main(){
cin.tie(0); ios::sync_with_stdio(false);
return 0;
}
***************************************************************************************************

struct Edge {
  int src, dst;
  Weight weight;
  Edge(int src, int dst, Weight weight) :
    src(src), dst(dst), weight(weight) { }
};
bool operator < (const Edge &e, const Edge &f) {
  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!
  

typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

typedef vector<int> Array;
typedef vector<Array> Matrix;


***************************************************************************************************


#define _CRT_SECURE_NO_WARNINGS
 
#define REP(i, n) for(decltype(n) i = 0; i < (n); i++)
#define REP2(i, x, n) for(decltype(x) i = (x); i < (n); i++)
#define REP3(i, x, n) for(decltype(x) i = (x); i <= (n); i++)
#define RREP(i, n) for (decltype(n) i = (n) - 1; i >= 0; i--)
 
#define ALL(a) (a).begin(),(a).end()
#define SORT(c) sort((c).begin(),(c).end())
#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())
 
using namespace std;
 
const int INF = 1000000000;
const double PI = 3.1415926535897932384626433832795;
 
// N, E, S, W
const int dx[4] = { 1, 0, -1, 0};
const int dy[4] = { 0, 1, 0, -1};
 
using LL = long long int;
using LD = long double;
using pii = pair<int, int>;
using pll = pair<LL, LL>;
using pdd = pair<double, double>;
using vi = vector<int>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vl = vector<LL>;
using vvl = vector<vl>;
using vvvl = vector<vvl>;
using vd = vector<double>;
using vs = vector<string>;
using vb = vector<bool>;
 
 **********************************************************************************************


#define _USE_MATH_DEFINES
#include<stdio.h>
#include<string>
#include<iostream>
#include<cctype>
#include<cstdio>
#include<vector>
#include<queue>
#include<stack>
#include<algorithm>
#include<math.h>
#include<set>
#include<map>
#include<iomanip>
#include<functional>
using namespace std;

#define ll long long
#define MOD 1000000007

****************************************************************************************************

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>	
#include<map>
#include<set>
#include<utility>
#include<cmath>
#include<cstring>
#include<queue>
#include<cstdio>
#include<sstream>
#include<iomanip>
#define loop(i,a,b) for(int i=a;i<b;i++) 
#define rep(i,a) loop(i,0,a)
#define pb push_back
#define mp make_pair
#define all(in) in.begin(),in.end()
#define shosu(x) fixed<<setprecision(x)
using namespace std;

**************************************************************************************************

//#define int long long
#define rep(i,a,b) for(int i=(a);i<(b);i++)
#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)
#define all(c) begin(c),end(c)
const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;
const int MOD = (int)(1e9) + 7;
template<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }
template<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }
 
template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
 
	ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }
 
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
 
	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while (b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if (u < 0) u += MOD;
		ModInt res; res.x = (unsigned)u;
		return res;
	}
};
template <int M>
ostream &operator << (ostream &os, const ModInt<M> &m) { return os << m.x; }
template <int M>
istream &operator >> (istream &is, ModInt<M> &m) { signed long long s; is >> s; m = ModInt<M>(s); return is; };
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while (k) {
		if (k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}
 
using mint = ModInt<1000000007>;

******************************************************************************************************

using namespace std;

//#define endl '\n'
#define ALL(a)  (a).begin(),(a).end()
#define SZ(a) int((a).size())
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)
#define REP(i,n)  FOR(i,0,n)
#define RREP(i,n) for (int i=(n)-1;i>=0;i--)
#define RBP(i,a) for(auto& i : a)
#ifdef LOCAL111
	#define DEBUG(x) cout<<#x<<": "<<(x)<<endl
#else
	#define DEBUG(x) true
#endif
#define F first
#define S second
#define SNP string::npos
#define WRC(hoge) cout << "Case #" << (hoge)+1 << ": "
#define rangej(a,b,c) ((a) <= (c) and (c) < (b))
#define rrangej(b,c) rangej(0,b,c)
template<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? "" : " ") << *ite; cout << endl;}
template<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}
template<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}

typedef pair<int,int> P;
typedef long long int LL;
typedef unsigned long long ULL;
typedef pair<LL,LL> LP;

void ios_init(){
	//cout.setf(ios::fixed);
	//cout.precision(12);
#ifdef LOCAL111
	return;
#endif
	ios::sync_with_stdio(false); cin.tie(0);	
}

*****************************************************************************************************************

int numofbits5(long bits)
{
    bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);
    bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);
    bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);
    bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);
    return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);
}

******************************************************************************************************************


#include <bits/stdc++.h>
using namespace std;

#ifdef _WIN32
#define scanfll(x) scanf("%I64d", x)
#define printfll(x) printf("%I64d", x)
#else
#define scanfll(x) scanf("%lld", x)
#define printfll(x) printf("%lld", x)
#endif
#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define mt make_tuple
#define mp make_pair
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

using ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; 
using vi = vector<int>; using vvi = vector<vi>;
vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }
using P = pair<ll, ll>;

template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};
template<class Ch, class Tr, class Tuple, size_t... Is>
void print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? "" : ", ") << get<Is>(t)), 0)...}; }
template<class Ch, class Tr, class... Args> 
auto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << "("; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << ")"; }
ostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << " "; cout << endl; } return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? ", " : ""); o << "]";  return o; }
template <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << "]";  return o; }
void printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }
#define ldout fixed << setprecision(40) 

static const double EPS = 1e-14;
static const long long INF = 1e18;
static const long long mo = 1e9+7;


***********************************************************************************************************************

グラフ

#include<vector>
#include<queue>
#include<functional>
#include<cfloat>
#include<tuple>
#include<set>
#include<stack>
 
const double INF = DBL_MAX / 3.0;
 
// Edge
class Edge {
public:
    Edge() {}
    Edge(const int f, const int t, const double w) :from_(f), to_(t), weight_(w) {}
    int from() const {return from_;}
    int to() const {return to_;}
    double weight() const {return weight_;}
private:
    int from_, to_;
    double weight_;
};
 
// Graph
class Graph {
public:
    explicit Graph(int s) :size_(s) {edge_.resize(s);}
 
    int size() const {return size_;}
    const std::vector<Edge>& edge(const int v) const {return edge_[v];}
 
    void add(const Edge& e);
    void add(const int from, const int to, const double weight);
    double Dijkstra(const int start, const int goal) const;
    double BellmanFord(const int start, const int goal) const;
    bool cut_vertex(const int v, const std::set<int>& visited) const;
    std::vector<std::vector<int>> Kosaraju() const;
private:
    void cut_vertex_reachability(const int from, std::set<int>& visited) const;
    void Kosaraju_dfs_postorder(const int from, std::vector<bool>& visited, std::stack<int>& order) const;
    std::vector<int> Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, const int from, std::vector<bool>& visited) const;
 
    int size_;
    std::vector<std::vector<Edge>> edge_;
};
 
// implements
void Graph::add(const Edge& e) {edge_[e.from()].push_back(e);}
 
void Graph::add(const int from, const int to, const double weight) {edge_[from].push_back(Edge(from, to, weight));}
 
double Graph::Dijkstra(const int start, const int goal) const {
    enum {COST, VERTEX};
    typedef std::tuple<double, int> Node;
 
    std::vector<int> visited(size(), 0);
    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;
    q.push(Node(0, start));
    while(!q.empty()) {
        double cost = std::get<COST>(q.top());
        int from = std::get<VERTEX>(q.top());
        q.pop();
        if(from == goal) return cost;
        if(visited[from]) continue;
        visited[from] = 1;
        for(const auto& e: edge(from)) q.push(Node(cost + e.weight(), e.to()));
    }
    return INF;
}
 
double Graph::BellmanFord(const int start, const int goal) const {
    std::vector<double> distance(size(), INF);
    distance[start] = 0;
    for(int step = 0; step <= size(); ++step) {
        for(int from = 0; from < size(); ++from) {
            for(const auto& e: edge(from)) {
                if(distance[from] + e.weight() >= distance[e.to()]) continue;
                if(step == size()) return INF;
                distance[e.to()] = distance[from] + e.weight();
            }
        }
    }
    return distance[goal];
}
 
bool Graph::cut_vertex(const int v, const std::set<int>& visited = std::set<int>()) const {
    std::set<int> dup = visited;
    for(const auto& e: edge(v)) {
        if(dup.count(e.to())) continue;
        cut_vertex_reachability(e.to(), dup);
        return dup.size() != size();
    }
    return dup.size() != size();
}
void Graph::cut_vertex_reachability(const int from, std::set<int>& visited) const {
    visited.insert(from);
    for(const auto& e: edge(from)) if(!visited.count(e.to())) cut_vertex_reachability(e.to(), visited);
}
 
std::vector<std::vector<int>> Graph::Kosaraju() const {
    std::vector<std::vector<int>> result;
 
    std::vector<bool> visited(size(), false);
    std::stack<int> order;
    for(int v = 0; v < size(); ++v) if(!visited[v]) Kosaraju_dfs_postorder(v, visited, order);
 
    std::vector<std::vector<Edge>> reverse_edge(size(), std::vector<Edge>());
    for(int v = 0; v < size(); ++v) for(const auto& e: edge(v)) reverse_edge[e.to()].push_back(Edge(e.to(), e.from(), e.weight()));
 
    visited = std::vector<bool>(size(), false);
    while(!order.empty()) {
        int v = order.top();
        order.pop();
        if(visited[v]) continue;
        result.push_back(Kosaraju_dfs_decompose(reverse_edge, v, visited));
    }
    return result;
}
void Graph::Kosaraju_dfs_postorder(const int from, std::vector<bool>& visited, std::stack<int>& order) const {
    visited[from] = true;
    for(const auto& e: edge(from)) if(!visited[e.to()]) Kosaraju_dfs_postorder(e.to(), visited, order);
    order.push(from);
}
std::vector<int> Graph::Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, const int from, std::vector<bool>& visited) const {
    std::vector<int> result;
    result.push_back(from);
    visited[from] = true;
    for(const auto& e: reverse_edge[from]) {
        if(visited[e.to()]) continue;
        std::vector<int> add = Kosaraju_dfs_decompose(reverse_edge, e.to(), visited);
        result.insert(result.end(), add.begin(), add.end());
    }
    return result;
}



***************************************************************************************************************
頂点Ｐ

class P
{
public:
  double x,y;
  P(){};P(double x,double y):x(x),y(y){};
  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}
  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}
  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}
  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}
  template<typename T> P operator*(T d){return P(x*d,y*d);}
  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}
  template<typename T> P operator/(T d){return P(x/d,y/d);}
  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}
  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}
  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}
  double norm(void){return sqrt(x*x+y*y);}
  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}
  P nvec(){return P(y,-x);}
  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}
  P reverseX(void){return P(-x,y);}
  P reverseY(void){return P(x,-y);}
  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}
  P floor(void){return P((int)x,(int)y);}
  double dot(const P&q){return x*q.x+y*q.y;}
  double det(const P&q){return x*q.y-y*q.x;}
  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}
  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}
  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}
};

**************************************************************************************************************
数学テンプレ

namespace arithmetic {
  template<typename T> class Addition {
  public:
    template<typename V> T operator+(const V& v) const {
      return T(static_cast<const T&>(*this)) += v;
    }
  };
 
  template<typename T> class Subtraction {
  public:
    template<typename V> T operator-(const V& v) const {
      return T(static_cast<const T&>(*this)) -= v;
    }
  };
 
  template<typename T> class Multiplication {
  public:
    template<typename V> T operator*(const V& v) const {
      return T(static_cast<const T&>(*this)) *= v;
    }
  };
 
  template<typename T> class Division {
  public:
    template<typename V> T operator/(const V& v) const {
      return T(static_cast<const T&>(*this)) /= v;
    }
  };
 
  template<typename T> class Modulus {
  public:
    template<typename V> T operator%(const V& v) const {
      return T(static_cast<const T&>(*this)) %= v;
    }
  };
}
 
template<typename T> class IndivisibleArithmetic : public arithmetic::Addition<T>, public arithmetic::Subtraction<T>, public arithmetic::Multiplication<T> {};
 
template<typename T> class Arithmetic : public IndivisibleArithmetic<T>, public arithmetic::Division<T> {};
 
template<typename T> class Ordered {
public:
  template<typename V> bool operator==(const V& v) const {
    return !(static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v));
  }
   
  template<typename V> bool operator!=(const V& v) const {
    return static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v);
  }
 
  template<typename V> bool operator>(const V& v) const {
    return static_cast<T>(v) < static_cast<const T&>(*this);
  }
 
  template<typename V> bool operator<=(const V& v) const {
    return !(static_cast<T>(v) < static_cast<const T&>(*this));
  }
 
  template<typename V> bool operator>=(const V& v) const {
    return !(static_cast<const T&>(*this) < static_cast<T>(v));
  }
};
 
template<typename T> inline T gcd(T a, T b) {
  return __gcd(a, b);
}
 
template<typename T> inline T lcm(T a, T b) {
  return a / gcd(a, b) * b;
}
 
template<typename T> inline T floor(T a, T b) {
  return floor(a / b) * b <= a ? floor(a / b) : floor(a / b) - 1;
}
 
template<typename T> inline T ceil(T a, T b) {
  return floor(a + b - 1, b);
}
 
template<typename T> inline T round(T a, T b) {
  return floor(a + b / 2);
}
 
template<typename T> inline T mod(T a, T b) {
  return a - floor(a, b) * b;
}
 
template<typename T> inline T factorial(T n) {
  return n <= 1 ? 1 : factorial(n - 1) * n;
}
 
class Real : public Arithmetic<Real>, public arithmetic::Modulus<Real>, public Ordered<Real> {
private:
  static long double EPS;
  long double val;
 
  operator long double() const {
    return val;
  }
 
public:
  Real() {}
 
  Real(long double val) : val(val) {}
 
  Real operator-() const {
    return -val;
  }
 
  template<typename T> Real operator+=(const T& r) {
    val += static_cast<long double>(r);
    return *this;
  }
 
  template<typename T> Real operator-=(const T& r) {
    val -= static_cast<long double>(r);
    return *this;
  }
 
  template<typename T> Real operator*=(const T& r) {
    val *= static_cast<long double>(r);
    return *this;
  }
 
  template<typename T> Real operator/=(const T& r) {
    val /= static_cast<long double>(r);
    return *this;
  }
 
  template<typename T> Real operator%=(const T& r) {
    return *this = mod(*this, static_cast<Real>(r));
  }
 
  template<typename T> Real operator-(const T& v) const {
    return Real(*this) -= v;
  }
 
  template<typename T> bool operator<(const T r) const {
    return val < static_cast<long double>(r) - EPS;
  }
 
  Real abs() const {
    return std::abs(val);
  }
 
  Real sqrt() const {
    return std::sqrt(val);
  }
 
  long double toLongDouble() const {
    return val;
  }
};
 
long double Real::EPS = 1e-8;
 
inline ostream& operator<<(ostream& os, const Real& a) {
  os << fixed << setprecision(15) << a.toLongDouble();
  return os;
}
 
inline istream& operator>>(istream& is, Real& a) {
    long double n;
    is >> n;
    a = n;
    return is;
}
 
Real floor(const Real& r) {
  return floor(r.toLongDouble());
}
 
class Point : public Arithmetic<Point> {
public:
  Real x, y;
 
  Point() {}
 
  Point(const Real& x) : x(x), y(0) {}
 
  Point(const Real& x, const Real& y) : x(x), y(y) {}
 
  Point operator+=(const Point& p) {
    x += p.x;
    y += p.y;
    return *this;
  }
 
  Point operator-=(const Point& p) {
    x -= p.x;
    y -= p.y;
    return *this;
  }
 
  Point operator*=(const Point& p) {
    Real xx = x * p.x - y * p.y;
    y = x * p.y + y * p.x;
    x = xx;
    return *this;
  }
 
  Point operator*=(const Real& r) {
    x *= r;
    y *= r;
    return *this;
  }
 
  Point operator/=(const Point& p) {
    Real nrm = p.norm();
    Real xx = (x * p.x + y * p.y) / nrm;
    y = (y * p.x - x * p.y) / nrm;
    x = xx;
    return *this;
  }
 
  Point operator/=(const Real& r) {
    x /= r;
    y /= r;
    return *this;
  }
 
  Real norm() const {
    return x * x + y * y;
  }
 
  Real abs() const {
    return norm().sqrt();
  }
 
  Point conj() const {
    return Point(x, -y);
  }
};
 
inline ostream& operator<<(ostream& os, const Point& point) {
    os << point.x << " " << point.y;
    return os;
}
 
inline istream& operator>>(istream& is, Point& point) {
  Real x, y;
    is >> x >> y;
    point = Point(x, y);
    return is;
}
 
class Line {
public:
  Point a, b;
 
  Line() {}
 
  Line (const Point& a, const Point& b) : a(a), b(b) {}
 
  bool operator==(const Line& line) const {
    return ((line.vec() / vec()).y == 0) && (((line.a - a) / vec()).y == 0);
  }
 
  Point vec() const {
    return b - a;
  }
};
 
inline ostream& operator<<(ostream& os, const Line& line) {
    os << line.a << " " << line.b;
    return os;
}
 
inline istream& operator>>(istream& is, Line& line) {
  Point a, b;
  is >> a >> b;
  line = Line(a, b);
  return is;
}
 
class Segment : public Line {
public:
  Segment() {}
 
  Segment (const Point& a, const Point& b) : Line(a, b) {}
};
 
enum CCW{LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};
 
int ccw(const Segment& segment, const Point& point) {
  Point p = (point - segment.a) / segment.vec();
  if (p.y > 0) return LEFT;
  if (p.y < 0) return RIGHT;
  if (p.x < 0) return BACK;
  if (p.x > 1) return FRONT;
  return ON;
}
 
template<bool strict = false> inline bool intersect(const Line& line1, const Line& line2) {
  if (strict) return (line1.vec() / line2.vec()).y != 0;
  return ((line1.vec() / line2.vec()).y != 0) || (line1 == line2);
}
 
template<bool strict = false> inline bool intersect(const Line& line, const Segment& segment) {
  Point p1 = segment.a / line.vec(), p2 = segment.b / line.vec();
  if (strict) return p1.y * p2.y < 0;
  return p1.y * p2.y <= 0;
}
 
template<bool strict = false> inline bool intersect(const Segment& segment, const Line& line) {
  return intersect(line, segment);
}
 
template<bool strict = false> inline bool intersect(const Segment& segment1, const Segment& segment2) {
  int ccw1 = ccw(segment1, segment2.a) | ccw(segment1, segment2.b);
  int ccw2 = ccw(segment2, segment1.a) | ccw(segment2, segment1.b);
  if (strict) return (ccw1 & ccw2) == (LEFT | RIGHT);
  return ((ccw1 & ccw2) == (LEFT | RIGHT)) || ((ccw1 | ccw2) & ON);
}

*******************************************************************************************************

// 平面幾何
 
// 型変換
//   double  -> Point
//   Segment -> Line
 
////////////////////
// ライブラリ
#include<cmath>
#include<algorithm>
#include<cassert>
////////////////////
// 定数
const double EPS = 1e-9;
////////////////////
// 構造体
struct Point {
  double x, y;
  Point(const double d = 0.0) :x(d), y(d) {}
  Point(const double x, const double y) :x(x), y(y) {}
};
struct Segment {
  Point initial, terminal;
  Segment(const Point& initial = 0, const Point& terminal = 0) :initial(initial), terminal(terminal) {}
};
struct Line {
  Point initial, terminal;
  Line(const Point& initial = 0, const Point& terminal = 0) :initial(initial), terminal(terminal) {}
  Line(const Segment& s) :initial(s.initial), terminal(s.terminal) {}
};
////////////////////
// 実装
// bool operator==(const Point& lhs, const Point& rhs) {return lhs.x == rhs.x && lhs.y == rhs.y;}
// bool operator<(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y;}
// bool operator>(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x > rhs.x : lhs.y > rhs.y;}
// bool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}
// bool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}
// bool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}
const Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}
const Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}
const Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}
const Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}
const Point operator-(const Point& p) {return Point(-p.x, -p.y);}
// 点
double abs(const Point& p) {return std::hypot(p.x, p.y);}
double norm(const Point& p) {return p.x * p.x + p.y * p.y;}
double dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}
double cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}
// const Point normalize(const Point& p) {return p / hypot(p.x, p.y);}
// 線
bool parallel(const Line& l1, const Line& l2) {return std::abs(cross(l2.terminal - l2.initial, l1.terminal - l1.initial)) <= EPS;}
bool orthogonal(const Line& l1, const Line& l2) {return std::abs(dot(l2.terminal - l2.initial, l1.terminal - l1.initial)) <= EPS;}
// 点の位置関係
enum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK}; 
POSITION ccw(const Point& a, const Point& b, const Point& p) {
  Point v1 = b - a;
  Point v2 = p - a;
  if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;
  if(cross(v1, v2) < -EPS) return CLOCKWISE;
  if(dot(v1, v2) < -EPS) return ONLINE_BACK;
  if(norm(v2) - norm(v1) > EPS) return ONLINE_FRONT;
  return ON_SEGMENT;
}
// 交差判定
bool intersect(const Point& p1, const Point& p2) {return p1.x == p2.x && p1.y == p2.y;}
bool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}
bool intersect(const Segment& s, const Point& p) {return intersect(p, s);}
bool intersect(const Point& p, const Line& l) {return !parallel(l.terminal - p, l.initial - p);}
bool intersect(const Line& l, const Point& p) {return intersect(p, l);}
bool intersect(const Segment& s1, const Segment& s2) {
  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0
      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;
}
bool intersect(const Segment& s, const Line& l) {
  auto v1 = l.terminal - l.initial;
  auto v2 = s.initial  - l.initial;
  auto v3 = s.terminal - l.initial;
  return cross(v1, v2) * cross(v1, v3) <= EPS;
}
bool intersect(const Line& l, const Segment& s) {return intersect(s, l);}
bool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || parallel(l1, Line(l1.initial, l2.initial));}  // 非平行または同一直線上
// 点移動
Point projection(const Point& p, const Line& l) {
  auto v = l.initial - l.terminal;
  return l.initial + dot(p - l.initial, v) / norm(v) * v;
}
Point projection(const Line& l, const Point& p) {return projection(p, l);}
Point reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}
Point reflection(const Line& l, const Point& p) {return reflection(p, l);}
// 距離
double distance(const Point& p1, const Point& p2) {
  auto p = p1 - p2;
  return hypot(p.x, p.y);
}
double distance(const Point& p, const Segment& s) {
  auto r = projection(s, p);
  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));
}
double distance(const Segment& s, const Point& p) {return distance(p, s);}
double distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}
double distance(const Line& l, const Point& p) {return distance(p, l);}
double distance(const Segment& s1, const Segment& s2) {
  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial),
                                             distance(s1, s2.terminal),
                                             distance(s2, s1.initial),
                                             distance(s2, s1.terminal)});
}
double distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}
double distance(const Line& l,const Segment& s) {return distance(s, l);}
double distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}
// 交点
const Point crosspoint(const Line& l1, const Line& l2) {
  double A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);
  double B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);
  if(std::abs(A) < EPS && std::abs(B) < EPS) return l2.initial;
  assert(std::abs(A) > EPS);                                // 平行かつ同一直線上にない
  return l2.initial + B / A * (l2.terminal - l2.initial);
}
const Point crosspoint(const Segment& s, const Line& l) {
  Point cp = crosspoint(Line(s), l);
  assert(intersect(s, cp));                                 // 2直線の交点が線分上にない
  return cp;
}
const Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}
const Point crosspoint(const Segment& s1, const Segment& s2) {
  Point cp = crosspoint(Line(s1), Line(s2));
  assert(intersect(s1, cp) && intersect(s2, cp));           // 2直線の交点が線分上にない
  return cp;
}
// デバッグ用
// #include<bits/stdc++.h>
// using namespace std;
// void print(const Point& p) {cout<<"("<<p.x<<","<<p.y<<")";}
// void print(const Line& l) {print(l.initial); cout<<" - ";print(l.terminal);}
////////////////////////////////////////////////////////////////////////////////
// 多角形
//   辺をメンバ変数に持たないようにすればメモリ節約（1/3くらい？） + シンプルに記述 + edge(void)がO(n)
#include<vector>
#include<algorithm>
#include<utility>
class Polygon {
public:
  void add(const Point& p) {
    if(!vertex_.empty()) {
      if(!edge_.empty()) edge_.pop_back();
      edge_.push_back(Segment(vertex_.back(), p));
      edge_.push_back(Segment(p, vertex_.front()));
    }
    vertex_.push_back(p);
  }
  int size() const {return vertex_.size();}
  Point vertex(const int n) const {return vertex_.at(n);}
  Segment edge(const int n) const {return edge_.at(n);}
  const std::vector<Point>& vertex() const {return vertex_;}
  const std::vector<Segment>& edge() const {return edge_;}
  bool touch(const Point& p) const {
    return std::any_of(edge_.begin(), edge_.end(), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});
  }
  bool include(const Point& p) const {  // intersect()という名前にしたいけどグローバルスコープのintersect()たちが隠蔽されて困った
    bool in = false;                    // p=(x,y)から(INF,y)への半直線と多角形とが交差する回数 mod 2
    for(const auto& e: edge()) {
      if(intersect(p, e)) return true;
      Point a = e.initial  - p;
      Point b = e.terminal - p;
      if(a.y > b.y) std::swap(a, b);
      if(a.y <= EPS && 0.0 < b.y && cross(a, b) < EPS) in = !in;
    }
    return in;
  }
    void clear() {
      vertex_.clear();
      edge_.clear();
    };
private:
  std::vector<Point> vertex_;
  std::vector<Segment> edge_;
};


例
   Segment s(Point(a, b), Point(c, d));
    Segment t(Point(e, f), Point(g, h));
    cout << (intersect(s, t) ? 1 : 0) << endl;
    
    
************************************************************************************************************

#ifndef ___Geometry_Library
#define ___Geometry_Library
 
// ------ Includes ------ //
#include <cmath>
#include <complex>
#include <utility>
#include <algorithm>
 
// ------ Defines ------ //
typedef long double GType;
typedef std::complex<GType> Point;
typedef std::pair<Point, Point> Segment;
 
// ------ Constants ------ //
const GType EPS = 1.0e-10L;
 
// ------ Functions Level 1 ------ //
GType dot(const Point& p1, const Point& p2) {
    return (std::conj(p1) * p2).real();
}
GType cross(const Point& p1, const Point& p2) {
    return (std::conj(p1) * p2).imag();
}
int ccw(const Point& p1, const Point& p2, const Point& p3) {
    Point v1 = p2 - p1, v2 = p3 - p1;
    if (cross(v1, v2) > EPS) return +1;
    if (cross(v1, v2) < -EPS) return -1;
    if (dot(v1, v2) < -EPS) return +2;
    if (std::norm(v1) < std::norm(v2)) return -2;
    return 0;
}
 
// ------ Functions Level 2 ------ //
bool intersect(const Segment& s1, const Point& p1, bool segflag) {
    if (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;
    return (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;
}
bool intersect(const Segment& s1, const Segment& s2, bool segflag) {
    if (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;
    return (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second)) <= 0 && (ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second)) <= 0;
}
 
#endif
 
#include <iostream>
using namespace std;
int q, xa, ya, xb, yb; Segment s1, s2;
int main() {
    cin >> q;
    while (q--) {
        cin >> xa >> ya >> xb >> yb; s1 = make_pair(Point(xa, ya), Point(xb, yb));
        cin >> xa >> ya >> xb >> yb; s2 = make_pair(Point(xa, ya), Point(xb, yb));
        if (intersect(s1, s2, true)) cout << 1 << endl;
        else cout << 0 << endl;
    }
    return 0;
}


*----------------------------------------------*******************************************************



#pragma region GNUC
//https://yukicoder.me/wiki/auto_vectorization
#ifdef __GNUC__
#pragma GCC optimize ("O3")
#pragma GCC target ("avx")
#endif
#pragma endregion
#define _USE_MATH_DEFINES
#pragma region
#include <iostream>
#include <iomanip>
#include <stdio.h>
 
#include <sstream>
#include <algorithm>
#include <cmath>
 
#include <string>
#include <cstring>
#include <vector>
 
#include <queue>
#include <complex>
#include <set>
#include <map>
#include <stack>
#include <list>
 
#include <fstream>
#include <random>
#pragma endregion //#include
/////////
#define REP(i, x, n) for(int i = x; i < n; ++i)
#define rep(i,n) REP(i,0,n)
/////////
#pragma region
typedef long long LL;
typedef long double LD;
typedef unsigned long long ULL;
#pragma endregion //typedef
////定数
const int INF = (int)1e9;
const int MOD = (int)1e9+7;
const LL LINF = (LL)1e18;
/////////
using namespace::std;
/////////
#pragma region Math
// 最大公約数
template<class T>
inline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}
//inline T gcd(T a, T b){return b == 0 ? a : gcd(b, a % b);}
 
// 最小公倍数
template<class T>
inline T lcm(T a, T b){return a / gcd(a, b) * b;}
//inline T lcm(T a, T b){return a * b / gcd(a, b);}
 
template<class T>
T powMod(T num,int n,T mod=MOD){
	if( n == 0 ){
		return (T)1;
	}
	T mul = num;
	T ans = (T)1;
	while(n){
		if( n&1){
			ans = (ans*mul)%mod;
		}
		mul = (mul*mul)%mod;
		n >>= 1;
	}
	return ans;
}
#pragma endregion //math
#pragma region
template<class T>
void UNIQUE(vector<T>& vec){
	sort(vec.begin(),vec.end());
	vec.erase(unique(vec.begin(),vec.end()),vec.end() );
}
#pragma endregion // sort erase unique
////////////////////////////////
#pragma region 
long long  bitcount64(long long bits)
{
    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);
    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);
    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);
    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);
    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);
    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);
}
#pragma endregion //その他
////////////////////////////////
struct edge{int to;LL cost;};
edge make_edge(int to,LL cost){
	edge ret = {to,cost};
	return ret;
}
#pragma region //グラフ
void dijkstra(int root,int V,vector<LL>& dist,
	vector< vector<edge> > G	){
	priority_queue<pair<LL,int>,vector<pair<LL,int> >,greater<pair<LL,int> > > que;
	dist.assign(V,LINF);
	dist[root] = 0;
	que.push(pair<LL,int>(0,root));//距離、頂点番号
 
	while( !que.empty() ){
		pair<LL,int> p = que.top();que.pop();
		int v = p.second;
		if( dist[v] < p.first ) continue;
		for(int i=0;i < (int)G[v].size();++i){
			edge e = G[v][i];
			if( dist[e.to] > dist[v] + e.cost ){
				dist[e.to] = dist[v] + e.cost;
				que.push(pair<LL,int>(dist[e.to],e.to));
			}
		}
	}
}
#pragma endregion //ダイクストラ法:O(|E|log|V|)
#pragma region //グラフ
void warshall_floyd(vector<vector<LL> >& dist,int V,const LL INF=LINF){
	for(int k=0;k<V;++k){
		for(int i=0;i<V;++i){
			if( dist[i][k] >= INF ) continue;
			for(int j=0;j<V;++j){
				if( dist[k][j] >= INF )continue;
				dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);
			}
		}
	}
}
#pragma endregion //ワーシャルフロイド:O(|V|**3)
#pragma region 
//http://sugarknri.hatenablog.com/entry/2016/07/16/165715
//LL inv[1000010];
void makeinv(vector<LL>& inv,const LL P){
	int i;
	inv = vector<LL>(1000010,0);
	inv[1]=1;
	for(i=2;i<=1000000;i++){
		inv[i] = inv[P%i] * (P-P/i)%P;//OVF
	}
}
 
ULL nCk(ULL N,ULL k){
	static vector<LL> inv;
	if( inv.size() == 0 ){
		makeinv(inv,MOD);
	}
	k = min(k,N-k);
	if( k == 0 ){return 1;}
	if( k == 1 ){return N%MOD;}
	ULL ret = 1;
	for(int i=1;i<=k;++i){
		ret *= ((N+1-i)*inv[i])%MOD;//OVF
		ret %= MOD;
	}
	return ret;
}
#pragma endregion //組み合わせnCk(,10^5)
#pragma region CGL
class Point{
public:
	double x,y;
	Point(double x=0,double y=0):x(x),y(y){}
 
	Point	operator +	(Point p){return Point(add(x,p.x),add(y,p.y));}
	void	operator +=	(Point p){x=add(x,p.x);y=add(y,p.y);}
	Point	operator -	(Point p){return Point(add(x,-p.x),add(y,-p.y));}
	void	operator -=	(Point p){x=add(x,-p.x);y=add(y,-p.y);}
	Point	operator *	(double a){return Point(x*a,y*a);}
	double	operator *	(Point p){return dot(p);}
	Point	operator /	(double a){return Point(x/a,y/a);}
 
	double norm(){return sqrt(x*x+y*y);}
	double dot(Point p){return add(x*p.x,y*p.y);}
	double rot(Point p){return add(x*p.y,-y*p.x);}
	double add(double a,double b){
		double EPS = 1e-10;
		if( abs(a+b) < EPS*(abs(a)+abs(b)) ){
			return 0;
		}
		return a+b;
	}
};
istream& operator>>(istream& in,Point& P){
	in >> P.x >> P.y;
	return in;
}
 
//線分p1-p2上に点qがあるか判定
bool on_seg(Point p1,Point p2,Point q){
	return (p1-q).rot(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;
}
Point intersection(Point p1,Point p2,Point q1,Point q2){
	return p1+(p2-p1)*((q2-q1).rot(q1-p1)/(q2-q1).rot(p2-p1));
}
enum PointPotion{ON_SEGMENT,COUNTER_CLOCKWISE,ONLINE_BACK,CLOCKWISE,ONLINE_FRONT};
PointPotion ccw(Point A,Point B,Point C){
	B -= A;C -=A;
	if( B.rot(C) > 0 ) return COUNTER_CLOCKWISE;
	if( B.rot(C) < 0 ) return CLOCKWISE;
	if( B.dot(C) < 0 ) return ONLINE_BACK;
	if( B.norm() < C.norm() ) return ONLINE_FRONT;
	return ON_SEGMENT;
}
#pragma endregion //class Point
#pragma region
//辞書順で比較
bool cmp_x(const Point& p,const Point& q){
	if( p.x != q.x ) return p.x < q.x;
	return p.y < q.y;
}
 
//凸包を求める
vector<Point> convex_hull(vector<Point> ps,int n){
	sort(ps.begin(),ps.end(), cmp_x);
	int k = 0;//凸包の頂点数
	vector<Point> qs(n*2);//構築中の凸包
	//下側の凸包の作成
	for(int i=0;i<n;++i){
		while(k>1 && (qs[k-1]-qs[k-2]).rot(ps[i]-qs[k-1]) <=0){
			k--;
		}
		qs[k++] = ps[i];
	}
	//上側凸包の作成
	for(int i=n-2,t=k;i>=0;i--){
		while(k>t && (qs[k-1]-qs[k-2]).rot(ps[i]-qs[k-1]) <=0){
			k--;
		}
		qs[k++] = ps[i];
	}
	qs.resize(k-1);
	return qs;
}
#pragma endregion //凸包
#pragma region 
template<class T,class U>
istream& operator>>(istream& in,pair<T,U> P){
	in >> P.first >> P.second;
	return in;
}
#pragma endregion //cin pair<T,U>
/*
#pragma region 
//行列の積
vector< vector<LL> > operator*( vector<vector<LL> >& A,vector< vector<LL> >& B){
	LL mod = MOD;
	int R = A.size();
	int cen = A[0].size();
	int C = B[0].size();
	vector< vector<LL> > ans(R,vector<LL>(C,0) );
	for(int row=0;row<R;++row){
		for(int col=0;col<C;++col){
			for(int inner=0;inner< cen;++inner){
				ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;
			}
		}
	}
	return ans;
}
 
vector< vector<LL> > powMod(vector< vector<LL> > mat,LL N){
	int R = mat.size();
	int C = mat[0].size();
	//R==C
	vector< vector<LL> > I(R,vector<LL>(C,0));//単位元
	for(int i=0;i<R && i<C;++i){
		I[i][i] = 1;
	}
	if( N == 0 ){
		return I;
	}
	vector< vector<LL> > mul(R,vector<LL>(C)),ans(R,vector<LL>(C));
	ans = I;
	mul = mat;
	while(N){
		if( N & 1 ){
			ans = ans*mul;
		}
		N >>= 1;
		mul = mul*mul;
	}
	return ans;
}
#pragma endregion //行列
*/
vector< vector<LL> > MulBit( vector<vector<LL> >& A,vector< vector<LL> >& B){
	int R = A.size();
	int cen = A[0].size();
	int C = B[0].size();
	vector< vector<LL> > ans(R,vector<LL>(C,0) );
	
	int row = 0;
	for(row=0;row<R;++row){
		for(int col=0;col<C;++col){
			for(int inner=0;inner< cen;++inner){
				ans[row][col] = (ans[row][col] ^ (A[row][inner] & B[inner][col]));
			}
		}
	}
	
	return ans;
}
vector< vector<LL> > powBit(vector< vector<LL> > mat,LL N){
	int R = mat.size();
	int C = mat[0].size();
	vector< vector<LL> > mul(R,vector<LL>(C)),ans(R,vector<LL>(C,0));
	for(int i=0;i<R&&i<C;++i){
		ans[i][i] = (1LL<<32)-1;
	}
	mul = mat;
	while(N){
		if( N & 1 ){
			ans = MulBit(ans,mul);
		}
		N >>= 1;
		mul = MulBit(mul,mul);
	}
	return ans;
}
#pragma region 
#pragma endregion //
const double PI = acos(-1.0);
const double EPS = 1e-9;
 
******************************************************************************************************

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <map>
#include <algorithm>
#include <sstream>
#include <cmath>
#include <set>
#include <iomanip>
#include <deque>
#include <stdio.h>
using namespace std;
 
#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)
#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)
#define FOREACH(i,Itr) for(auto (i)=(Itr).begin();(i)!=(Itr).end();(i)++)
#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())
#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())
#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())
#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))
#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))
#define EPS 1.0e-8
#define MOD 1000000007
typedef long long ll;
 
struct Point {
    double x,y;
    Point(){}
    Point(double _x, double _y):x(_x),y(_y){}
    bool operator < (const Point &a) const {
        return (x==a.x) ? (y<a.y) : (x<a.x);
    }
};
Point operator +(const Point &a,const Point &b){return Point(a.x+b.x,a.y+b.y);}
Point operator -(const Point &a,const Point &b){return Point(a.x-b.x,a.y-b.y);}
Point operator *(const Point &a,double k){return Point(a.x*k,a.y*k);}
 
struct Segment {
    Point p1,p2;
    Segment(){}
    Segment(Point _p1, Point _p2):p1(_p1),p2(_p2){}
    Segment(double x1, double y1, double x2, double y2)
    :p1(Point(x1,y1)),p2(Point(x2,y2)){}
};
 
struct Circle {
    Point c; double r;
    Circle(){}
    Circle(Point _c, double _r):c(_c),r(_r){}
    Circle(double x, double y, double _r):c(Point(x,y)),r(_r){}
};
 
typedef Point Vector;
typedef Segment Line;
typedef vector<Point> Polygon;
 
double dot(Vector a, Vector b){return a.x*b.x + a.y*b.y;}
double cross(Vector a, Vector b){return a.x*b.y - a.y*b.x;}
double norm(Vector a){return sqrt(dot(a,a)*dot(a,a));}
 
Point Project(Segment s, Point p) {
    Vector base = s.p2 - s.p1;
    double r = dot(p - s.p1, base) / norm(base);
    return s.p1 + base * r;
}
 
Point Reflect(Segment s, Point p) {
    return p + (Project(s,p) - p) * 2.0;
}
 
double DistanceLinePoint(Line s, Point p) {
    Vector dist = Project(s,p) - p;
    return sqrt(norm(dist));
}
 
double DistanceSegmentPoint(Segment s, Point p) {
    if(dot(s.p2 - s.p1, p -s.p1)<0.0)return sqrt(norm(p - s.p1));
    if(dot(s.p1 - s.p2, p -s.p2)<0.0)return sqrt(norm(p - s.p2));
    return DistanceLinePoint(s,p);
}
 
const int COUNTER_CLOCKWISE = 1;
const int CLOCKWISE = -1;
const int ONLINE_BACK = 2;
const int ONLINE_FRONT = 2;
const int ON_SEGMENT = 0;
int CounterClockwise(Point p0, Point p1, Point p2) {
    Vector a = p1 - p0;
    Vector b = p2 - p0;
    if(cross(a,b)>1.0e-8)return COUNTER_CLOCKWISE;
    if(cross(a,b)<-1.0e-8)return CLOCKWISE;
    if(dot(a,b)<-1.0e-8)return ONLINE_BACK;
    if(norm(a)<norm(b))return ONLINE_FRONT;
    return ON_SEGMENT;
}
 
bool Intersect(Point p1, Point p2, Point p3, Point p4) {
   return (CounterClockwise(p1,p2,p3) * CounterClockwise(p1,p2,p4) <= 0 &&
           CounterClockwise(p3,p4,p1) * CounterClockwise(p3,p4,p2) <= 0);
}
 
bool Intersect(Segment s1, Segment s2) {
    return Intersect(s1.p1,s1.p2,s2.p1,s2.p2);
}
 
Point CrossPoint(Segment s1, Segment s2){
    Vector base = s2.p2 - s2.p1;
    double d1 = abs(cross(base,s1.p1 - s2.p1));
    double d2 = abs(cross(base,s1.p2 - s2.p1));
    double t = d1 / (d1+d2);
    return s1.p1 + (s1.p2-s1.p1) * t;
}
 
Polygon ConvexHull(vector<Point> pos) {
    int n = (int)pos.size(), k = 0;
    sort(pos.begin(),pos.end());
    Polygon ch(2*n);
    for(int i=0;i<n;ch[k++]=pos[i++])
        while(k>=2 && CounterClockwise(ch[k-2],ch[k-1],pos[i])<=0)--k;
    for(int i=n-2,t=k+1;i>=0;ch[k++]=pos[i--])
        while(k>=t && CounterClockwise(ch[k-2],ch[k-1],pos[i])<=0)--k;
    ch.resize(k-1);
    return ch;
}
 
double ConvexDiameter(Polygon &pos) {
    int n = (int)pos.size();
    int is = 0, js = 0;
    for(int i=1;i<n;++i) {
        if (pos[i].y > pos[is].y) is = i;
        if (pos[i].y < pos[js].y) js = i;
    }
    double maxd = norm(pos[is]-pos[js]);
    
    int i, maxi, j, maxj;
    i = maxi = is;
    j = maxj = js;
    do{
        if(cross(pos[(i+1)%n]-pos[i],pos[(j+1)%n]-pos[j])>=0)j=(j+1)%n;
        else i=(i+1)%n;
        if(norm(pos[i]-pos[j]) > maxd) {
            maxd = norm(pos[i]-pos[j]);
            maxi = i; maxj = j;
        }
    }while(i!=is || j!=js);
    return sqrt(maxd);
}

****************************************************************************************************

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <math.h>
#include <complex>
using namespace std;
#define rep(i,n) for (int i=0; i < (n); i++)

// 主に以下の資料を参考に作成した。
// - http://www.prefield.com/algorithm
// - http://www.deqnotes.net/acmicpc/2d_geometry/
// - https://github.com/infnty/acm/tree/master/lib/geometry
// - サークルの先輩が作ったライブラリ

/* 基本要素 */

typedef double D;      // 座標値の型。doubleかlong doubleを想定
typedef complex<D> P;  // Point
typedef pair<P, P> L;  // Line
typedef vector<P> VP;
const D EPS = 1e-9;    // 許容誤差。問題によって変える
#define X real()
#define Y imag()
#define LE(n,m) ((n) < (m) + EPS)
#define GE(n,m) ((n) + EPS > (m))
#define EQ(n,m) (abs((n)-(m)) < EPS)

// 内積　dot(a,b) = |a||b|cosθ
D dot(P a, P b) {
  return (conj(a)*b).X;
}
// 外積　cross(a,b) = |a||b|sinθ
D cross(P a, P b) {
  return (conj(a)*b).Y;
}

// 点の進行方向
int ccw(P a, P b, P c) {
  b -= a;  c -= a;
  if (cross(b,c) >  EPS) return +1;  // counter clockwise
  if (cross(b,c) < -EPS) return -1;  // clockwise
  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line
  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b
  return 0;                          // a--c--b on line or a==c or b==c
}

/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */

// 直線と点
bool isecLP(P a1, P a2, P b) {
  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価
}

// 直線と直線
bool isecLL(P a1, P a2, P b1, P b2) {
  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);
}

// 直線と線分
bool isecLS(P a1, P a2, P b1, P b2) {
  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;
}

// 線分と線分
bool isecSS(P a1, P a2, P b1, P b2) {
  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&
         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;
}

// 線分と点
bool isecSP(P a1, P a2, P b) {
  return !ccw(a1, a2, b);
}


/* 距離　各直線・線分は縮退してはならない */

// 点pの直線aへの射影点を返す
P proj(P a1, P a2, P p) {
  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);
}

// 点pの直線aへの反射点を返す
P reflection(P a1, P a2, P p) {
  return 2.0*proj(a1, a2, p) - p;
}

D distLP(P a1, P a2, P p) {
  return abs(proj(a1, a2, p) - p);
}

D distLL(P a1, P a2, P b1, P b2) {
  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);
}

D distLS(P a1, P a2, P b1, P b2) {
  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));
}

D distSP(P a1, P a2, P p) {
  P r = proj(a1, a2, p);
  if (isecSP(a1, a2, r)) return abs(r-p);
  return min(abs(a1-p), abs(a2-p));
}

D distSS(P a1, P a2, P b1, P b2) {
  if (isecSS(a1, a2, b1, b2)) return 0;
  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),
             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));
}

// 2直線の交点
P crosspointLL(P a1, P a2, P b1, P b2) {
  D d1 = cross(b2-b1, b1-a1);
  D d2 = cross(b2-b1, a2-a1);
  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line
  if (EQ(d2, 0)) throw "kouten ga nai";   // 交点がない
  return a1 + d1/d2 * (a2-a1);
}


/* 円 */

D distLC(P a1, P a2, P c, D r) {
  return max(distLP(a1, a2, c) - r, 0.0);
}

D distSC(P a1, P a2, P c, D r) {
  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);
  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える
  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));
  return max(distSP(a1, a2, c) - r, 0.0);
}

VP crosspointLC(P a1, P a2, P c, D r) {
  VP ps;
  P ft = proj(a1, a2, c);
  if (!GE(r*r, norm(ft-c))) return ps;

  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);
  ps.push_back(ft + dir);
  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);
  return ps;
}

D distCC(P a, D ar, P b, D br) {
  D d = abs(a-b);
  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;
}

// 2円の交点
VP crosspointCC(P a, D ar, P b, D br) {
  VP ps;
  P ab = b-a;
  D d = abs(ab);
  D crL = (norm(ab) + ar*ar - br*br) / (2*d);
  if (EQ(d, 0) || ar < abs(crL)) return ps;

  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);
  P cp = a + crL/d * ab;
  ps.push_back(cp + abN);
  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);
  return ps;
}

// 点pから円aへの接線の接点
VP tangentPoints(P a, D ar, P p) {
  VP ps;
  D sin = ar / abs(p-a);
  if (!LE(sin, 1)) return ps;  // ここでNaNも弾かれる
  D t = M_PI_2 - asin(min(sin, 1.0));
  ps.push_back(                 a + (p-a)*polar(sin, t));
  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));
  return ps;
}

// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる
vector<L> tangentLines(P a, D ar, P b, D br) {
  vector<L> ls;
  D d = abs(b-a);
  rep (i,2) {
    D sin = (ar - (1-i*2)*br) / d;
    if (!LE(sin*sin, 1)) break;
    D cos = sqrt(max(1 - sin*sin, 0.0));
    rep (j,2) {
      P n = (b-a) * P(sin, (1-j*2)*cos) / d;
      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));
      if (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）
    }
  }
  return ls;
}

// 三角形の外心。点a,b,cは同一線上にあってはならない
P circumcenter(P a, P b, P c) {
  a = (a-c)*0.5;
  b = (b-c)*0.5;
  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));
}

// 点aと点bを通り、半径がrの円の中心を返す
VP circlesPointsRadius(P a, P b, D r) {
  VP cs;
  P abH = (b-a)*0.5;
  D d = abs(abH);
  if (d == 0 || d > r) return cs;  // 必要なら !LE(d,r) として円1つになる側へ丸める
  D dN = sqrt(r*r - d*d);          // 必要なら max(r*r - d*d, 0) とする
  P n = abH * P(0,1) * (dN / d);
  cs.push_back(a + abH + n);
  if (dN > 0) cs.push_back(a + abH - n);
  return cs;
}

// 点aと点bを通り、直線lに接する円の中心
VP circlesPointsTangent(P a, P b, P l1, P l2) {
  P n = (l2-l1) * P(0,1);
  P m = (b-a) * P(0,0.5);
  D rC = dot((a+b)*0.5-l1, n);
  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);
  D qb = -rC * dot(n,m);
  D qc = norm(n)*norm(m) - rC*rC;
  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0

  VP cs;
  if (qd < -EPS) return cs;
  if (EQ(qa, 0)) {
    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));
    return cs;
  }
  D t = -qb/qa;
  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));
  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));
  return cs;
}

// 点集合を含む最小の円の中心
P minEnclosingCircle(const VP& ps) {
  P c;
  double move = 0.5;
  rep(i,39) {  // 2^(-39-1) \approx 0.9e-12
    rep(t,50) {
      D max = 0;
      int k = 0;
      rep (j, ps.size()) if (max < norm(ps[j]-c)) {
        max = norm(ps[j]-c);
        k = j;
      }
      c += (ps[k]-c) * move;
    }
    move /= 2;
  }
  return c;
}


/* 多角形 */

// 頂点の順序（sortやmax_elementに必要）
namespace std {
  bool operator<(const P a, const P b) {
    return a.X != b.X ? a.X < b.X : a.Y < b.Y;
  }
}

// 凸包
VP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に
  int n = ps.size(), k = 0;
  sort(ps.begin(), ps.end());
  VP ch(2*n);
  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull
    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする
  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull
    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
  ch.resize(k-1);
  return ch;
}

// 凸判定。縮退を認めないならccwの判定部分を != 1 とする
bool isCcwConvex(const VP& ps) {
  int n = ps.size();
  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;
  return true;
}

// 凸多角形の内部判定　O(n)
// 点が領域内部なら1、境界上なら2、外部なら0を返す
int inConvex(P p, const VP& ps) {
  int n = ps.size();
  int dir = ccw(ps[0], ps[1], p);
  rep (i, n) {
    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);
    if (!ccwc) return 2;  // 線分上に存在
    if (ccwc != dir) return 0;
  }
  return 1;
}

// 凸多角形の内部判定　O(logn)
// 点が領域内部なら1、境界上なら2、外部なら0を返す
int inCcwConvex(const VP& ps, P p) {
  int n = ps.size();
  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;
  if (g == p) return 1;
  P gp = p - g;

  int l = 0, r = n;
  while (l + 1 < r) {
    int mid = (l + r) / 2;
    P gl = ps[l] - g;
    P gm = ps[mid] - g;
    if (cross(gl, gm) > 0) {
      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;
      else l = mid;
    }
    else {
      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;
      else r = mid;
    }
  }
  r %= n;
  D cr = cross(ps[l] - p, ps[r] - p);
  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;
}

// 多角形の内部判定
// 点が領域内部なら1、境界上なら2、外部なら0を返す
int inPolygon(const VP& ps, P p) {
  int n = ps.size();
  bool in = false;
  rep (i, n) {
    P a = ps[i] - p;
    P b = ps[(i + 1) % n] - p;
    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;
    if (a.Y > b.Y) swap(a,b);
    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;
  }
  return in;
}

// 凸多角形クリッピング
VP convexCut(const VP& ps, P a1, P a2) {
  int n = ps.size();
  VP ret;
  rep(i,n) {
    int ccwc = ccw(a1, a2, ps[i]);
    if (ccwc != -1) ret.push_back(ps[i]);
    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);
    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));
  }
  return ret;
}

// 凸多角形の直径（最遠点対）
pair<int, int> convexDiameter(const VP& ps) {
  int n = ps.size();
  int i = min_element(ps.begin(), ps.end()) - ps.begin();
  int j = max_element(ps.begin(), ps.end()) - ps.begin();
  int maxI, maxJ;
  D maxD = 0;
  rep(_, 2*n) {
    if (maxD < norm(ps[i]-ps[j])) {
      maxD = norm(ps[i]-ps[j]);
      maxI = i;
      maxJ = j;
    }
    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;
    else                                                      i = (i+1) % n;
  }
  return make_pair(maxI, maxJ);
}

// 多角形の符号付面積
D area(const VP& ps) {
  D a = 0;
  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);
  return a / 2;
}

// 多角形の幾何学的重心
P centroid(const VP& ps) {
  int n = ps.size();
  D aSum = 0;
  P c;
  rep (i, n) {
    D a = cross(ps[i], ps[(i+1) % n]);
    aSum += a;
    c += (ps[i] + ps[(i+1) % n]) * a;
  }
  return 1 / aSum / 3 * c;
}

// ボロノイ領域
VP voronoiCell(P p, const VP& ps, const VP& outer) {
  VP cl = outer;
  rep (i, ps.size()) {
    if (EQ(norm(ps[i]-p), 0)) continue;
    P h = (p+ps[i])*0.5;
    cl = convexCut(cl, h, h + (ps[i]-h)*P(0,1) );
  }
  return cl;
}

/* 幾何グラフ */

struct Edge {
  int from, to;
  D cost;
  Edge(int from, int to, D cost) : from(from), to(to), cost(cost) {}
};
struct Graph {
  int n;
  vector<vector<Edge> > edges;
  Graph(int n) : n(n), edges(n) {}
  void addEdge(Edge e) {
    edges[e.from].push_back(e);
    edges[e.to].push_back(Edge(e.to, e.from, e.cost));
  }
};

// 線分アレンジメント（線分の位置関係からグラフを作成）
Graph segmentArrangement(const vector<L>& segs, VP& ps) {
  int n = segs.size();
  rep (i, n) {
    ps.push_back(segs[i].first);
    ps.push_back(segs[i].second);
    rep (j, i) {
      if (isecSS(                 segs[i].first, segs[i].second, segs[j].first, segs[j].second))
        ps.push_back(crosspointLL(segs[i].first, segs[i].second, segs[j].first, segs[j].second));
    }
  }
  sort(ps.begin(), ps.end());
  ps.erase(unique(ps.begin(), ps.end()), ps.end());

  int m = ps.size();
  Graph gr(m);
  vector<pair<D, int> > list;
  rep (i, n) {
    list.clear();
    rep (j, m) {
      if (isecSP(segs[i].first, segs[i].second, ps[j]))
        list.push_back(make_pair(norm(segs[i].first-ps[j]), j));
    }
    sort(list.begin(), list.end());
    rep (j, list.size() - 1) {
      int a = list[j  ].second;
      int b = list[j+1].second;
      gr.addEdge(Edge(a, b, abs(ps[a]-ps[b])));
    }
  }
  return gr;
}

// 可視グラフ（点集合から見える位置へ辺を張ったグラフ）
Graph visibilityGraph(const VP& ps, const vector<VP>& objs) {
  int n = ps.size();
  Graph gr(n);
  rep (i,n) rep (j,i) {
    P a = ps[i], b = ps[j];
    if (!EQ(norm(a-b), 0)) rep (k, objs.size()) {
      const VP& obj = objs[k];
      int inStA = inConvex(a, obj);
      int inStB = inConvex(b, obj);
      if ((inStA ^ inStB) % 2 || inStA * inStB != 1 && inConvex((a+b)*0.5, obj) == 1) goto skip;
      rep (l, obj.size()) {
        P cur = obj[l];
        P next = obj[(l + 1) % obj.size()];
        if (isecSS(a, b, cur, next) && !isecSP(cur, next, a) && !isecSP(cur, next, b)) goto skip;
      }
    }
    gr.addEdge( Edge(i, j, abs(a-b)) );
    skip: {}
  }
  return gr;
}


/* その他 */

// 重複する線分を併合する
vector<L> mergeSegments(vector<L> segs) {
  int n = segs.size();
  rep (i,n) if (segs[i].second < segs[i].first) swap(segs[i].second, segs[i].first);

  rep (i,n) rep (j,i) {
    L &l1 = segs[i], &l2 = segs[j];
    if (EQ(cross(l1.second-l1.first, l2.second-l2.first), 0)
        && isecLP(l1.first, l1.second, l2.first)
        && ccw   (l1.first, l1.second, l2.second) != 2
        && ccw   (l2.first, l2.second, l1.second) != 2) {
      segs[j] = L(min(l1.first, l2.first), max(l1.second, l2.second));
      segs[i--] = segs[--n];
      break;
    }
  }
  segs.resize(n);
  return segs;
}


// この辺にコードを載せるほどでもないが重要な定理とか図とか書いておくとよい気がします

// 余弦定理
// △ABC において、a = BC, b = CA, c = AB としたとき
// a^2 = b^2 + c^2 ? 2bc cos ∠CAB

// ヘロンの公式
// 3辺の長さがa,b,cである三角形の面積T
// T = sqrt{ s(s-a)(s-b)(s-c) }, s = (a+b+c)/2

// ピックの定理
// 多角形の頂点が全て格子点上にあり、内部に穴がないとき
// S = i + b/2 - 1 (S:多角形の面積, i: 多角形の内部にある格子点の数, b: 辺上の格子点の数)


********************************************************************************************************


#include <ctime>
#include <sstream>
#include <iostream>

using namespace std;

class Date {
	int y;	// 西暦年
	int m;	// 月
	int d;	// 日
	static int dmax[];
	static int day_of_month(int y, int m);		// y年m月の日数

public:
	Date();										// デフォルトコンストラクタ
	Date(int yy, int mm = 1, int dd = 1);		// コンストラクタ

	// y年は閏年か？
	static bool leap_year(int year) {
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}

	int year()  const { return y; }			// 年を返却
	int month() const { return m; }			// 月を返却
	int day()   const { return d; }			// 日を返却
	bool leap_year() const { return leap_year(y); }		// 閏年か？
	Date preceding_day() const;				// 前日の日付を返却
	Date following_day() const;				// 翌日の日付を返却

	int day_of_year() const;				// 年内の経過日数を返却

	int day_of_week() const;				// 曜日を返却

	std::string to_string() const;			// 文字列表現を返却
};

std::ostream& operator<<(std::ostream& s, const Date& x);		// 挿入子


// 平年の各月の日数
int Date::dmax[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

//--- y年m月の日数を求める ---//
int Date::day_of_month(int y, int m)
{
	return dmax[m - 1] + (leap_year(y) && m == 2);
}

//--- Dateのデフォルトコンストラクタ（今日の日付に設定）---//
Date::Date()
{
	time_t current = time(NULL);				// 現在の暦時刻を取得
	struct tm* local = localtime(&current);		// 要素別の時刻に変換

	y = local->tm_year + 1900;		// 年：tm_yearは西暦年-1900
	m = local->tm_mon + 1;			// 月：tm_monは0〜11
	d = local->tm_mday;
}

//--- Dateのコンストラクタ（指定された年月日に設定）---//
Date::Date(int yy, int mm, int dd)
{
	y = yy;
	m = mm;
	d = dd;
}

//--- 年内の経過日数を返却 ---//
int Date::day_of_year() const
{
	int days = d;	// 年内の経過日数

	for (int i = 1; i < m; i++)			// 1月〜(m-1)月の日数を加える
		days += day_of_month(y, i);
	return days;
}

//--- 前日の日付を返却 ---//
Date Date::preceding_day() const
{
	Date temp = *this;		// 同一の日付

	if (temp.d > 1)
		temp.d--;
	else {
		if (--temp.m < 1) {
			temp.y--;
			temp.m = 12;
		}
		temp.d = day_of_month(temp.y, temp.m);
	}
	return temp;
}

//--- 翌日の日付を返却 ---//
Date Date::following_day() const
{
	Date temp = *this;		// 同一の日付

	if (temp.d < day_of_month(temp.y, temp.m))
		temp.d++;
	else {
		if (++temp.m > 12) {
			temp.y++;
			temp.m = 1;
		}
		temp.d = 1;
	}
	return temp;
}

//--- 文字列表現を返却 ---//
string Date::to_string() const
{
	ostringstream s;
	s << y << "年" << m << "月" << d << "日";
	return s.str();
}

//--- 曜日を返却（日曜〜土曜が0〜6に対応）---//
int Date::day_of_week() const
{
	int yy = y;
	int mm = m;
	if (mm == 1 || mm == 2) {
		yy--;
		mm += 12;
	}
	return (yy + yy / 4 - yy / 100 + yy / 400 + (13 * mm + 8) / 5 + d) % 7;
}

//--- 出力ストリームsにxを挿入 ---//
ostream& operator<<(ostream& s, const Date& x)
{
	return s << x.to_string();
}