/* 幾何の基本 */

#include <complex>

typedef long double ld;
typedef complex<ld> Point;

const ld eps = 1e-9, pi = acos(-1.0);

namespace std {
	bool operator<(const Point &lhs, const Point &rhs) {
		if (lhs.real() < rhs.real() - eps) return true;
		if (lhs.real() > rhs.real() + eps) return false;
		return lhs.imag() < rhs.imag();
	}
}

// 点の入力
Point input_point() {
	ld x, y;
	cin >> x >> y;
	return Point(x, y);
}

// 誤差つき等号判定
bool eq(ld a, ld b) {
	return (abs(a - b) < eps);
}

// 内積
ld dot(Point a, Point b) {
	return real(conj(a) * b);
}

// 外積
ld cross(Point a, Point b) {
	return imag(conj(a) * b);
}

// 直線の定義
class Line {
public:
	Point a, b;
	Line() : a(Point(0, 0)), b(Point(0, 0)) {}
	Line(Point a, Point b) : a(a), b(b) {}
	Point operator[](const int _num) {
		if (_num == 0)return a;
		else if (_num == 1)return b;
		else assert(false);
	}
};

// 円の定義
class Circle {
public:
	Point p;
	ld r;
	Circle() : p(Point(0, 0)), r(0) {}
	Circle(Point p, ld r) : p(p), r(r) {}
};

// CCW
int ccw(Point a, Point b, Point c) {
	b -= a; c -= a;
	if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ
	if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ
	if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ
	if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ
	return 0;                          // a,c,bの順に直線に並ぶ
}


/* 交差判定 */

// 直線と直線の交差判定
bool isis_ll(Line l, Line m) {
	return !eq(cross(l.b - l.a, m.b - m.a), 0);
}

// 直線と線分の交差判定
bool isis_ls(Line l, Line s) {
	return isis_ll(l, s) &&
		(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);
}

// 線分と線分の交差判定
bool isis_ss(Line s, Line t) {
	return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&
		ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;
}

// 点の直線上判定
bool isis_lp(Line l, Point p) {
	return (abs(cross(l.b - p, l.a - p)) < eps);
}

// 点の線分上判定
bool isis_sp(Line s, Point p) {
	return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);
}

// 垂線の足
Point proj(Line l, Point p) {
	ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);
	return l.a + t * (l.a - l.b);
}

// 直線と直線の交点
Point is_ll(Line s, Line t) {
	Point sv = s.b - s.a, tv = t.b - t.a;
	assert(cross(sv, tv) != 0);
	return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);
}

// 直線と点の距離
ld dist_lp(Line l, Point p) {
	return abs(p - proj(l, p));
}

// 直線と直線の距離
ld dist_ll(Line l, Line m) {
	return isis_ll(l, m) ? 0 : dist_lp(l, m.a);
}

// 直線と線分の距離
ld dist_ls(Line l, Line s) {
	return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));
}

// 線分と点の距離
ld dist_sp(Line s, Point p) {
	Point r = proj(s, p);
	return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));
}

// 線分と線分の距離
ld dist_ss(Line s, Line t) {
	if (isis_ss(s, t)) return 0;
	return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });
}


/* 円 */

// 円と円の交点
vector<Point> is_cc(Circle c1, Circle c2) {
	vector<Point> res;
	ld d = abs(c1.p - c2.p);
	ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);
	ld dfr = c1.r * c1.r - rc * rc;
	if (abs(dfr) < eps) dfr = 0.0;
	else if (dfr < 0.0) return res; // no intersection
	ld rs = sqrt(dfr);
	Point diff = (c2.p - c1.p) / d;
	res.push_back(c1.p + diff * Point(rc, rs));
	if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));
	return res;
}

// 円と直線の交点
vector<Point> is_lc(Circle c, Line l) {
	vector<Point> res;
	ld d = dist_lp(l, c.p);
	if (d < c.r + eps) {
		ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;
		Point nor = (l.a - l.b) / abs(l.a - l.b);
		res.push_back(proj(l, c.p) + len * nor);
		res.push_back(proj(l, c.p) - len * nor);
	}
	return res;
}

// 円と線分の距離
vector<Point> is_sc(Circle c, Line l) {
	vector<Point> v = is_lc(c, l), res;
	for (Point p : v)
		if (isis_sp(l, p)) res.push_back(p);
	return res;
}

// 円と点の接線
vector<Line> tangent_cp(Circle c, Point p) {
	vector<Line> ret;
	Point v = c.p - p;
	ld d = abs(v);
	ld l = sqrt(norm(v) - c.r * c.r);
	if (isnan(l)) { return ret; }
	Point v1 = v * Point(l / d, c.r / d);
	Point v2 = v * Point(l / d, -c.r / d);
	ret.push_back(Line(p, p + v1));
	if (l < eps) return ret;
	ret.push_back(Line(p, p + v2));
	return ret;
}

// 円と円の接線
vector<Line> tangent_cc(Circle c1, Circle c2) {
	vector<Line> ret;
	if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {
		Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);
		ret = tangent_cp(c1, center);
	}
	if (abs(c1.r - c2.r) > eps) {
		Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);
		vector<Line> nret = tangent_cp(c1, out);
		ret.insert(ret.end(), nret.begin(),nret.end());
	}
	else {
		Point v = c2.p - c1.p;
		v /= abs(v);
		Point q1 = c1.p + v * Point(0, 1) * c1.r;
		Point q2 = c1.p + v * Point(0, -1) * c1.r;
		ret.push_back(Line(q1, q1 + v));
		ret.push_back(Line(q2, q2 + v));
	}
	return ret;
}


/* 多角形 */

typedef vector<Point> Polygon;

// 面積
ld area(const Polygon &p) {
	ld res = 0;
	int n = p.size();
	for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);
	return res / 2;
}

// 多角形の回転方向
bool is_counter_clockwise(const Polygon &poly) {
	ld angle = 0;
	int n = poly.size();
	for (int i = 0;i < n;i++) {
		Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];
		angle += arg((c - b) / (b - a));
	}
	return angle > eps;
}

// 凸性判定
bool isConvex(const Polygon &poly){
    int n = (int)poly.size();
    if(n < 3) return false;
    int s = -3;
    for(int i = 0; i < n;i++){
        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);
        if(r == 1 && s == -3) s = r;
        if(s*r == -1) return false;
    }
    return true;
}

// 円の内外判定
//  2 => out
//  0 => on
//  1 => in
int is_in_polygon(const Polygon &poly, Point p) {
	ld angle = 0;
	int n = (int)poly.size();
	for (int i = 0;i < n;i++) {
		Point a = poly[i], b = poly[(i + 1) % n];
		if (isis_sp(Line(a, b), p)) return 1;
		angle += arg((b - p) / (a - p));
	}
	return eq(angle, 0) ? 0 : 2;
}

// 凸包
Polygon convex_hull(vector<Point> ps) {
    int n = (int)ps.size();
    if(n < 3) return ps;
    sort(ps.begin(), ps.end());
    Polygon u = {ps[0], ps[1]},l = {ps[n-1],ps[n-2]};
    for(int i = 2; i < n; i++){
        for(int j = (int)u.size(); j>=2 && ccw(u[j-2],u[j-1],ps[i])>=0;j--)u.pop_back();
        u.push_back(ps[i]);
    }
    for(int i = n-3;i>=0;i--){
        for(int j = (int)l.size(); j>=2 && ccw(l[j-2],l[j-1],ps[i])>=0;j--)l.pop_back();
        l.push_back(ps[i]);
    }
    reverse(l.begin(),l.end());
    for(int i=(int)u.size()-2; i>= 1; i--)l.push_back(u[i]);
    return l;
}

// 凸カット
Polygon convex_cut(const Polygon &ps, Line l) {
	int n = (int)ps.size();
	Polygon Q;
	for (int i = 0;i < n;i++) {
		Point A = ps[i], B = ps[(i + 1) % n];
		Line m = Line(A, B);
		if (ccw(l.a, l.b, A) != -1) Q.push_back(A);
		if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))
			Q.push_back(is_ll(l, m));
	}
	return Q;
}


/* アレンジメント */
void add_point(vector<Point> &ps, Point p) {
	for (Point q : ps) if (abs(q - p) < eps) return;
	ps.push_back(p);
}

typedef int Weight;

struct Edge { int from, to; Weight weight; };

typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

void add_edge(Graph &g, int from, int to, Weight weight) {
	g[from].push_back(Edge{ from, to, weight });
}

Graph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {
	int n = p.size(), m = s.size();
	Graph g(n);
	for (int i = 0;i < m;i++) {
		vector<pair<ld, int>> vec;
		for (int j = 0;j < n;j++) if (isis_sp(s[i], p[j]))
			vec.emplace_back(abs(s[i].a - p[j]), j);
		sort(vec.begin(),vec.end());
		for (int j = 0;j < vec.size() - 1;j++) {
			int from = vec[j].second, to = vec[j + 1].second;
			add_edge(g, from, to, abs(p[from] - p[to]));
		}
	}
	return g;
}

Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {
	int n = p.size(), m = c.size();
	Graph g(n);
	for (int i = 0;i < m;i++) {
		vector<pair<ld, int>> vec;
		for (int j = 0; j < n;j++) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)
			vec.emplace_back(arg(c[i].p - p[j]), j);
		sort(vec.begin(),vec.end());
		for (int j = 0;j < vec.size() - 1;j++) {
			int from = vec[j].second, to = vec[j + 1].second;
			ld angle = vec[j + 1].first - vec[j].first;
			add_edge(g, from, to, angle * c[i].r);
		}
		if (vec.size() >= 2) {
			int from = vec.back().second, to = vec.front().first;
			ld angle = vec.front().first - vec.back().first;
			add_edge(g, from, to, angle * c[i].r);
		}
	}
	return g;
}


/* 双対グラフ */

// 線分集合は既にアレンジメントされていなければならない．
// 内側の円は時計回りで，外側の円は反時計回りで得られる．
// 変数 polygon は，vector<int> で表される多角形の集合であり，
// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．
vector<vector<int>> polygon;
vector<int> seg2p[1024][1024];

Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {
	int N = p.size();
	polygon.clear();
	for (int i = 0;i < 1024;i++) for (int j = 0;j < 1024;j++) seg2p[i][j].clear();
	vector<vector<tuple<ld, int, bool>>> tup(N);
	for (int i = 0;i < s.size();i++) {
		int a = -1, b = -1;
		for (int j = 0;j < N;j++) if (abs(s[i].a - p[j]) < eps) a = j;
		for (int j = 0;j < N;j++) if (abs(s[i].b - p[j]) < eps) b = j;
		assert(a >= 0 && b >= 0);
		tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);
		tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);
	}
	for (int i = 0;i < N;i++) sort(tup[i].begin(),tup[i].end());
	for (int i = 0;i < N;i++) {
		for (int j = 0;j < tup[i].size();j++) {
			ld angle; int pos = j, from = i, to; bool flag;
			tie(angle, to, flag) = tup[i][j];
			if (flag) continue;
			vector<int> ps;
			while (!flag) {
				ps.push_back(from);
				get<2>(tup[from][pos]) = true;
				seg2p[from][to].push_back(polygon.size());
				seg2p[to][from].push_back(polygon.size());
				angle += pi + eps;
				if (angle > pi) angle -= 2 * pi;
				auto it = lower_bound(tup[to].begin(),tup[to].end(), make_tuple(angle, 0, false));
				if (it == tup[to].end()) it = tup[to].begin();
				from = to; tie(angle, to, flag) = *it;
				pos = it - tup[from].begin();
			}
			polygon.push_back(ps);
		}
	}
	Graph g(polygon.size());
	for (int i = 0;i < N;i++) for (int j = 0;j < i;j++) {
		if (seg2p[i][j].size() == 2) {
			int from = seg2p[i][j][0], to = seg2p[i][j][1];
			g[from].push_back(Edge{ from, to });
			g[to].push_back(Edge{ to, from });
		}
	}
	return g;
}


/* ビジュアライザ */
const ld zoom = 25;
const ld centerX = 6;
const ld centerY = 5;

void change_color(int r, int g, int b) {
	fprintf(stderr, "c.strokeStyle = 'rgb(%d, %d, %d)';\n", r, g, b);
}

int cordx(Point p) { return 400 + zoom * (p.real() - centerX); }
int cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }

#define cord(p) cordx(p),cordy(p)

void draw_point(Point p) {
	fprintf(stderr, "circle(%d, %d, %d)\n", cord(p), 2);
}

void draw_segment(Line l) {
	fprintf(stderr, "line(%d, %d, %d, %d)\n", cord(l.a), cord(l.b));
}

void draw_line(Line l) {
	Point v = l.b - l.a;
	Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));
	fprintf(stderr, "line(%d, %d, %d, %d)\n", cord(m.a), cord(m.b));
}

void draw_polygon(const Polygon &p) {
	int n = p.size();
	for (int i = 0;i < n;i++) draw_segment(Line(p[i], p[(i + 1) % n]));
}

void draw_circle(Circle c) {
	fprintf(stderr, "circle(%d, %d, %d)\n", cord(c.p), (int)(zoom * c.r));
}


***************************************************************************
**************************************************************************************************

//#define int long long
#define rep(i,a,b) for(int i=(a);i<(b);i++)
#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)
#define all(c) begin(c),end(c)
const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;
const int MOD = (int)(1e9) + 7;
template<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }
template<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }

	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while (b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if (u < 0) u += MOD;
		ModInt res; res.x = (unsigned)u;
		return res;
	}
};
template <int M>
ostream &operator << (ostream &os, const ModInt<M> &m) { return os << m.x; }
template <int M>
istream &operator >> (istream &is, ModInt<M> &m) { signed long long s; is >> s; m = ModInt<M>(s); return is; };
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while (k) {
		if (k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}

using mint = ModInt<1000000007>;




*****/////////////////////////////////////////////////////////////////////////////////////////////////////


3次元対応

#define int long long
#define DBG 0
#define dump(o) if(DBG){cerr<<#o<<" "<<(o)<<endl;}
#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<" "<<e;cerr<<endl;}
#define rep(i,a,b) for(int i=(a);i<(b);i++)
#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)
#define all(c) begin(c),end(c)
const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;
const int MOD = (int)(1e9 + 7);
 
const double EPS = 1e-10;
#define equals(a,b) (fabs((a)-(b)) < EPS)
 
class Point {
public:
    double x, y, z;
    Point(double x = 0, double y = 0, double z = 0) :x(x), y(y), z(z) {}
 
    Point operator+(Point p) { return Point(x + p.x, y + p.y, z + p.z); }
    Point operator-(Point p) { return Point(x - p.x, y - p.y, z - p.z); }
    Point operator*(double a) { return Point(a * x, a * y, a*z); }
    Point operator/(double a) { return Point(x / a, y / a, z / a); }
    bool operator<(const Point &p)const {
        if (x < p.x)return true;
        if (x > p.x)return false;
        if (y < p.y)return true;
        if (y > p.y)return false;
        if (z < p.z)return true;
        return false;
    }
    bool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y) && equals(z, p.z); }
 
    double abs() { return sqrt(norm()); }
    double norm() { return x*x + y*y + z*z; }
 
};
inline ostream &operator << (ostream &os, const Point &p) { os << p.x << " " << p.y << " " << p.z; return os; }
inline istream &operator >> (istream &is, Point &p) { double x, y, z; is >> x >> y >> z; p = Point(x, y, z); return is; }
 
using Vector = Point;
 
class Segment {
public:
    Point p1, p2;
    Segment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}
};
using Line = Segment;
 
//???
class Sphere {
public:
    Point c;
    double r;
    int w;
    Sphere(Point c = Point(), double r = 1.0) :c(c), r(r) {};
};
 
//http://www.math.s.chiba-u.ac.jp/~yasuda/Chiba/Lec/naiseki.pdf
//?????? dot product
double dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
//?????? cross product
Vector cross(Vector a, Vector b) {
    Vector ret;
    ret.x = a.y*b.z - a.z*b.y;
    ret.y = a.z*b.x - a.x*b.z;
    ret.z = a.x*b.y - a.y*b.x;
    return ret;
}
 
//?°???±
Point project(Segment s, Point p) {
    Vector base = s.p2 - s.p1;
    double r = dot(p - s.p1, base) / base.norm();
    return s.p1 + base*r;
}
 
//2???????????????
double get_distance(Point a, Point b) { return (a - b).abs(); }
//http://www.sousakuba.com/Programming/gs_dot_line_distance.html
//??´?????¨????????????
double get_distance_LP(Line l, Point p) { return cross(l.p2 - l.p1, p - l.p1).abs() / (l.p2 - l.p1).abs(); }
//????????¨????????????
double get_distance_SP(Segment s, Point p) {
    if (dot(s.p2 - s.p1, p - s.p1) < 0.0)return get_distance(p, s.p1);
    if (dot(s.p1 - s.p2, p - s.p2) < 0.0)return get_distance(p, s.p2);
    return get_distance_LP(s, p);
}
 
//?????¨?????????????????????
bool intersect(Sphere SP, Segment S) {
    return SP.r + EPS >= get_distance_SP(S, SP.c);
}
 
//?????¨??´????????????
pair<Point, Point> get_cross_points(Sphere SP, Line L) {
    assert(intersect(SP, L));
    Vector pr = project(L, SP.c);
    Vector e = (L.p2 - L.p1) / (L.p2 - L.p1).abs();
    double base = sqrt(SP.r*SP.r - (pr - SP.c).norm());
    return make_pair(pr + e*base, pr - e*base);
}


*******************************************************************************************************************
サイコロ

enum Dir {
    TOP,
    BOTTOM,
    FRONT,
    BACK,
    LEFT,
    RIGHT
};

int trans[6] = {-1, -1, 3, 1, 2, 0};
int memo[6][4] = {{3,5,4,2}, {3,1,4,6}, {1,2,6,5}, {1,5,6,2}, {1,3,6,4}, {2,4,5,3}};

class Dice {
public:
    Dice() {d.resize(6);}
    Dice(int top, int front) {
        d.resize(6);
        set(top, front);
    }
    int find(int num) const {
        for (int i = 0; i < 6; i++) if (num==d[i]) return i;
        assert(0);
        return -1;
    }
    int get(int dir) const {
        return d[dir];
    }
    void set(int top, int front) {
        d[TOP] = top;
        d[BOTTOM] = 7-top;
        d[FRONT] = front;
        d[BACK] = 7-front;
        int index = 0;
        for (; index < 4; index++) {
            if (memo[top-1][index] == front) break;
        }
        d[RIGHT] = memo[top-1][(index+1)%4];
        d[LEFT] = 7-d[RIGHT];
    }
    void rotate(int dir) {
        vector<int> nd = d;
        if (dir == 0) {
            nd[TOP] = d[LEFT];
            nd[LEFT] = d[BOTTOM];
            nd[BOTTOM] = d[RIGHT];
            nd[RIGHT] = d[TOP];
        }
        if (dir == 1) {
            nd[TOP] = d[FRONT];
            nd[FRONT] = d[BOTTOM];
            nd[BOTTOM] = d[BACK];
            nd[BACK] = d[TOP];
        }
        if (dir == 2) {
            nd[TOP] = d[RIGHT];
            nd[RIGHT] = d[BOTTOM];
            nd[BOTTOM] = d[LEFT];
            nd[LEFT] = d[TOP];
        }
        if (dir == 3) {
            nd[TOP] = d[BACK];
            nd[BACK] = d[BOTTOM];
            nd[BOTTOM] = d[FRONT];
            nd[FRONT] = d[TOP];
        }
        d = nd;
    }
private:
    vector<int> d;
};






























typedef long double ld;
typedef complex<ld> Point;
const ld eps = 1e-9, pi = acos(-1.0);
namespace std {bool operator<(const Point &lhs, const Point &rhs) {if (lhs.real() < rhs.real() - eps) return true;
if (lhs.real() > rhs.real() + eps) return false;return lhs.imag() < rhs.imag();}}
// 点の入力
Point input_point() {ld x, y;cin >> x >> y;return Point(x, y);}

// 誤差つき等号判定
bool eq(ld a, ld b) {return (abs(a - b) < eps);}

// 内積
ld dot(Point a, Point b) {return real(conj(a) * b);}

// 外積
ld cross(Point a, Point b) {
	return imag(conj(a) * b);
}

// 直線の定義
class Line {
public:
	Point a, b;
	Line() : a(Point(0, 0)), b(Point(0, 0)) {}
	Line(Point a, Point b) : a(a), b(b) {}
	Point operator[](const int _num) {
		if (_num == 0)return a;
		else if (_num == 1)return b;
		else assert(false);
	}
};

// 円の定義
class Circle {
public:
	Point p;
	ld r;
	Circle() : p(Point(0, 0)), r(0) {}
	Circle(Point p, ld r) : p(p), r(r) {}
};

// CCW
int ccw(Point a, Point b, Point c) {
	b -= a; c -= a;
	if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ
	if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ
	if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ
	if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ
	return 0;                          // a,c,bの順に直線に並ぶ
}


/* 交差判定 */

// 直線と直線の交差判定
bool isis_ll(Line l, Line m) {
	return !eq(cross(l.b - l.a, m.b - m.a), 0);
}

// 直線と線分の交差判定
bool isis_ls(Line l, Line s) {
	return isis_ll(l, s) &&
		(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);
}

// 線分と線分の交差判定
bool isis_ss(Line s, Line t) {
	return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&
		ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;
}

// 点の直線上判定
bool isis_lp(Line l, Point p) {
	return (abs(cross(l.b - p, l.a - p)) < eps);
}

// 点の線分上判定
bool isis_sp(Line s, Point p) {
	return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);
}

// 垂線の足
Point proj(Line l, Point p) {
	ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);
	return l.a + t * (l.a - l.b);
}

// 直線と直線の交点
Point is_ll(Line s, Line t) {
	Point sv = s.b - s.a, tv = t.b - t.a;
	assert(cross(sv, tv) != 0);
	return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);
}

// 直線と点の距離
ld dist_lp(Line l, Point p) {
	return abs(p - proj(l, p));
}

// 直線と直線の距離
ld dist_ll(Line l, Line m) {
	return isis_ll(l, m) ? 0 : dist_lp(l, m.a);
}

// 直線と線分の距離
ld dist_ls(Line l, Line s) {
	return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));
}

// 線分と点の距離
ld dist_sp(Line s, Point p) {
	Point r = proj(s, p);
	return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));
}

// 線分と線分の距離
ld dist_ss(Line s, Line t) {
	if (isis_ss(s, t)) return 0;
	return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });
}


/* 円 */

// 円と円の交点
vector<Point> is_cc(Circle c1, Circle c2) {
	vector<Point> res;
	ld d = abs(c1.p - c2.p);
	ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);
	ld dfr = c1.r * c1.r - rc * rc;
	if (abs(dfr) < eps) dfr = 0.0;
	else if (dfr < 0.0) return res; // no intersection
	ld rs = sqrt(dfr);
	Point diff = (c2.p - c1.p) / d;
	res.push_back(c1.p + diff * Point(rc, rs));
	if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));
	return res;
}

// 円と直線の交点
vector<Point> is_lc(Circle c, Line l) {
	vector<Point> res;
	ld d = dist_lp(l, c.p);
	if (d < c.r + eps) {
		ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;
		Point nor = (l.a - l.b) / abs(l.a - l.b);
		res.push_back(proj(l, c.p) + len * nor);
		res.push_back(proj(l, c.p) - len * nor);
	}
	return res;
}

// 円と線分の距離
vector<Point> is_sc(Circle c, Line l) {
	vector<Point> v = is_lc(c, l), res;
	for (Point p : v)
		if (isis_sp(l, p)) res.push_back(p);
	return res;
}

// 円と点の接線
vector<Line> tangent_cp(Circle c, Point p) {
	vector<Line> ret;
	Point v = c.p - p;
	ld d = abs(v);
	ld l = sqrt(norm(v) - c.r * c.r);
	if (isnan(l)) { return ret; }
	Point v1 = v * Point(l / d, c.r / d);
	Point v2 = v * Point(l / d, -c.r / d);
	ret.push_back(Line(p, p + v1));
	if (l < eps) return ret;
	ret.push_back(Line(p, p + v2));
	return ret;
}

// 円と円の接線
vector<Line> tangent_cc(Circle c1, Circle c2) {
	vector<Line> ret;
	if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {
		Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);
		ret = tangent_cp(c1, center);
	}
	if (abs(c1.r - c2.r) > eps) {
		Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);
		vector<Line> nret = tangent_cp(c1, out);
		ret.insert(ret.end(), nret.begin(),nret.end());
	}
	else {
		Point v = c2.p - c1.p;
		v /= abs(v);
		Point q1 = c1.p + v * Point(0, 1) * c1.r;
		Point q2 = c1.p + v * Point(0, -1) * c1.r;
		ret.push_back(Line(q1, q1 + v));
		ret.push_back(Line(q2, q2 + v));
	}
	return ret;
}


/* 多角形 */

typedef vector<Point> Polygon;

// 面積
ld area(const Polygon &p) {
	ld res = 0;
	int n = p.size();
	for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);
	return res / 2;
}

// 多角形の回転方向
bool is_counter_clockwise(const Polygon &poly) {
	ld angle = 0;
	int n = poly.size();
	for (int i = 0;i < n;i++) {
		Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];
		angle += arg((c - b) / (b - a));
	}
	return angle > eps;
}

// 円の内外判定
// -1 => out
//  0 => on
//  1 => in
int is_in_polygon(const Polygon &poly, Point p) {
	ld angle = 0;
	int n = poly.size();
	for (int i = 0;i < n;i++) {
		Point a = poly[i], b = poly[(i + 1) % n];
		if (isis_sp(Line(a, b), p)) return 1;
		angle += arg((b - p) / (a - p));
	}
	return eq(angle, 0) ? 0 : 2;
}

// 凸包
Polygon convex_hull(vector<Point> ps) {
	int n = ps.size();
	int k = 0;
	sort(ps.begin(), ps.end());
	Polygon ch(2 * n);
	for (int i = 0; i < n; ch[k++] = ps[i++])
		while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;
	for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])
		while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;
	ch.resize(k - 1);
	return ch;
}

// 凸カット
Polygon convex_cut(const Polygon &ps, Line l) {
	int n = ps.size();
	Polygon Q;
	for (int i = 0;i < n;i++) {
		Point A = ps[i], B = ps[(i + 1) % n];
		Line m = Line(A, B);
		if (ccw(l.a, l.b, A) != -1) Q.push_back(A);
		if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))
			Q.push_back(is_ll(l, m));
	}
	return Q;
}


/* アレンジメント */
void add_point(vector<Point> &ps, Point p) {
	for (Point q : ps) if (abs(q - p) < eps) return;
	ps.push_back(p);
}

typedef int Weight;

struct Edge { int from, to; Weight weight; };

typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

void add_edge(Graph &g, int from, int to, Weight weight) {
	g[from].push_back(Edge{ from, to, weight });
}

Graph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {
	int n = p.size(), m = s.size();
	Graph g(n);
	for (int i = 0;i < m;i++) {
		vector<pair<ld, int>> vec;
		for (int j = 0;j < n;j++) if (isis_sp(s[i], p[j]))
			vec.emplace_back(abs(s[i].a - p[j]), j);
		sort(vec.begin(),vec.end());
		for (int j = 0;j < vec.size() - 1;j++) {
			int from = vec[j].second, to = vec[j + 1].second;
			add_edge(g, from, to, abs(p[from] - p[to]));
		}
	}
	return g;
}

Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {
	int n = p.size(), m = c.size();
	Graph g(n);
	for (int i = 0;i < m;i++) {
		vector<pair<ld, int>> vec;
		for (int j = 0; j < n;j++) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)
			vec.emplace_back(arg(c[i].p - p[j]), j);
		sort(vec.begin(),vec.end());
		for (int j = 0;j < vec.size() - 1;j++) {
			int from = vec[j].second, to = vec[j + 1].second;
			ld angle = vec[j + 1].first - vec[j].first;
			add_edge(g, from, to, angle * c[i].r);
		}
		if (vec.size() >= 2) {
			int from = vec.back().second, to = vec.front().first;
			ld angle = vec.front().first - vec.back().first;
			add_edge(g, from, to, angle * c[i].r);
		}
	}
	return g;
}


/* 双対グラフ */

// 線分集合は既にアレンジメントされていなければならない．
// 内側の円は時計回りで，外側の円は反時計回りで得られる．
// 変数 polygon は，vector<int> で表される多角形の集合であり，
// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．
vector<vector<int>> polygon;
vector<int> seg2p[1024][1024];

Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {
	int N = p.size();
	polygon.clear();
	for (int i = 0;i < 1024;i++) for (int j = 0;j < 1024;j++) seg2p[i][j].clear();
	vector<vector<tuple<ld, int, bool>>> tup(N);
	for (int i = 0;i < s.size();i++) {
		int a = -1, b = -1;
		for (int j = 0;j < N;j++) if (abs(s[i].a - p[j]) < eps) a = j;
		for (int j = 0;j < N;j++) if (abs(s[i].b - p[j]) < eps) b = j;
		assert(a >= 0 && b >= 0);
		tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);
		tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);
	}
	for (int i = 0;i < N;i++) sort(tup[i].begin(),tup[i].end());
	for (int i = 0;i < N;i++) {
		for (int j = 0;j < tup[i].size();j++) {
			ld angle; int pos = j, from = i, to; bool flag;
			tie(angle, to, flag) = tup[i][j];
			if (flag) continue;
			vector<int> ps;
			while (!flag) {
				ps.push_back(from);
				get<2>(tup[from][pos]) = true;
				seg2p[from][to].push_back(polygon.size());
				seg2p[to][from].push_back(polygon.size());
				angle += pi + eps;
				if (angle > pi) angle -= 2 * pi;
				auto it = lower_bound(tup[to].begin(),tup[to].end(), make_tuple(angle, 0, false));
				if (it == tup[to].end()) it = tup[to].begin();
				from = to; tie(angle, to, flag) = *it;
				pos = it - tup[from].begin();
			}
			polygon.push_back(ps);
		}
	}
	Graph g(polygon.size());
	for (int i = 0;i < N;i++) for (int j = 0;j < i;j++) {
		if (seg2p[i][j].size() == 2) {
			int from = seg2p[i][j][0], to = seg2p[i][j][1];
			g[from].push_back(Edge{ from, to });
			g[to].push_back(Edge{ to, from });
		}
	}
	return g;
}


/* ビジュアライザ */
const ld zoom = 25;
const ld centerX = 6;
const ld centerY = 5;

void change_color(int r, int g, int b) {
	fprintf(stderr, "c.strokeStyle = 'rgb(%d, %d, %d)';\n", r, g, b);
}

int cordx(Point p) { return 400 + zoom * (p.real() - centerX); }
int cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }

#define cord(p) cordx(p),cordy(p)

void draw_point(Point p) {
	fprintf(stderr, "circle(%d, %d, %d)\n", cord(p), 2);
}

void draw_segment(Line l) {
	fprintf(stderr, "line(%d, %d, %d, %d)\n", cord(l.a), cord(l.b));
}

void draw_line(Line l) {
	Point v = l.b - l.a;
	Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));
	fprintf(stderr, "line(%d, %d, %d, %d)\n", cord(m.a), cord(m.b));
}

void draw_polygon(const Polygon &p) {
	int n = p.size();
	for (int i = 0;i < n;i++) draw_segment(Line(p[i], p[(i + 1) % n]));
}

void draw_circle(Circle c) {
	fprintf(stderr, "circle(%d, %d, %d)\n", cord(c.p), (int)(zoom * c.r));
}